{"posts":[{"title":"自动化测试---selenium","content":"一、前言 自动化测试工具： 功能（UI）自动化----QTP、selenium、appium 性能自动化----Loadrunner、Jmeter 接口自动化----jmeter、postman、souapui、Python、java 二、web自动化测试的价值 1） 自动化测试提高效率，缩短测试工作时间 2） 自动化测试和人工测试相比，每一次测试执行的操作时固定的，非常可靠 3） 自动化测试能加大每一轮回归的力度，提高测试的覆盖率 4） 自动化测试具备更好的重现软件缺陷的能力，具有很强的一致性和可重复性 三、开展自动化测试的条件 1、手工测试无法完成，需要投入大量的时间和人力 2、需求变更不频繁，比较稳定 3、项目周期足够长 4、自动化测试脚本可复用 5、手工测试基本通过 四、自动化测试的原理 手工执行用例： 1、打开浏览器，访问目标网址 2、点击登录，进入登陆页面 3、输入用户名 4、输入密码 5、点击登录 6、验证登陆成功 自动化执行用例： 1、调用API函数（webdriver）启动浏览器，使用get方法访问目标网址 2、通过定位目标对象的属性，使用click操作方法 3、通过定位目标对象的属性，使用send_keys操作方法 4、通过定位目标对象的属性，使用send_keys操作方法 5、通过定位目标对象的属性，使用click操作方法 6、使用断言函数（比较函数），判断是否登录成功 五、Python-selenium自动化测试环境搭建 1、 具备Python3环境 2、使用pip安装selenium 验证Python-selenium环境： 在开发工具中输入from selenium import webdriver不报错即可 webdriver是什么？ 相当于一个库，提供函数使用，selenium集成API编程接口，为动态网页提供良好的web能力 浏览器驱动下载目录：http://chromedriver.storage.googleapis.com/index.html 注意：如果找不到对应的版本，就找一个最相近的版本进行下载 驱动放置目录： 1-目标浏览器的安装目录下； 2-python的安装目录下； 3-通过指定路径的写法 示例： driver_path = r'C:\\User\\Liu\\AppData\\Local\\webdriver\\chromedriver.exe' dirver = webdriver.Chrome(executable_path = driver_path) 六、selenium—webdriver脚本编写 浏览器操作函数 driver=webdriver.Chrome()--------------------启动浏览器（第一个字母必须大写） driver.maximize_window()----------------------最大化浏览器 driver.minimize_window()-----------------------最小化浏览器 driver.back()---------------------------------后退 driver.forward()------------------------------前进 driver.quit()---------------------------------关闭浏览器 driver.close()--------------------------------关闭浏览器 drvier.refresh()------------------------------刷新浏览器 driver.get(url)-------------------------------访问目标网址 time.sleep(4)----------------前提导入--------import time 注： 1.quit退出且关闭所有有关联的窗口，close是关闭当前的窗口 2.driver.get(url)中的url必须用http开头 元素定位方式 id ---------------------------------find_element_by_id(id) class ----------------------------find_element_by_class_name(class) name ---------------------------find_element_by_name(name) link_text ------------------------find_element_by_link_text(link_text) partial_link_text --------------find_element_by_partial_link_text(link_text) tag_name----------------------find_element_by_tag_name(tag_name) xpath ---------------------------find_element_by_xpath(xpath) css ------------------------------find_element_by_css_selector(css_selector) 操作方法 click()----------------------------点击---强调事件的独立性 send_keys(‘xxx’)-----------------在输入框内输入xxx clear()----------------------------清空目标对象上的内容 submit()---------------------------提交---强调对表单内容的提交 text-------------------------------获取目标对象上的文本信息 注： 由于脚本执行速度过快，导致一些步骤执行失败，因为页面元素尚未渲染完成，脚本无法定位该对象，固在脚本步骤中添加一些必要的时间等待。 等待函数 driver.implicitly_wait(3)----------------智能等待，如果3s内元素已渲染完成，剩下的时间不再等待，若没有渲染完成，最大等待时间就为3s，对全局脚本均有效 time.sleep(3)----------------强制等待，无论3s内元素是否渲染完成，都要强制等待3s，对局部脚本有效 七、元素定位 Xpath定位 ​ XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初 XPath 的提出的初衷是将其作为一个通用的、介于XPointer与XSLT间的语法模型。但是 XPath 很快的被开发者采用来当作小型查询语言。 Xpath获取方式： 1） F12开发者工具，右键复制Xpath路径 2）手动编写 ​ 纯标签路径： position 绝对路径：/html/body/div/div[3]/div[2]/form/input 相当路径：//div[2]/form/input ​ 标签和属性结合: attribute 语法：//标签名[@属性=属性值] 示例： //input[@id=’word’] //form/input[@id=’word’]----标签可以有多个，也可以只有一个 //div[@class='hotwords']/a[1]&quot;---也可利用上层标签的属性进行定位 参考xpath选择器写法：https://www.w3school.com.cn/xpath/xpath_syntax.asp Css定位 ​ 层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 ​ CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。 CSS获取方式： 1） F12开发者工具，右键复制CSS路径 2）手动编写 标签和属性组合：标签名[属性名=属性值] ----标签名可以多个，多个时需要用空格隔开：form input.text ----属性可以随意：input[type='text']&quot; 示例：Input[class=’xxx’] 注意： class/id除了可以采用[属性=属性值]的写法，还可以用专用写法， 通过class编写：标签名.class的属性值 通过id编写：标签名#id的值 组合 ：标签名#id值.class值 参考css选择器写法链接：https://www.w3school.com.cn/cssref/css_selectors.asp 多窗口或框架内定位 切换框架 框架中的元素无法定位时需要切换到框架中在进行定位，且勿忘记跳出框架 函数： driver.switch_to.frame(&quot;xx&quot;)--------进入框架（可用框架的id/name/index，也可用其他定位方式） switch_to.default_content()--------跳出框架（跳出最近进入的框架） ​ 示例： id = &quot;abc&quot; driver.switch_to.frame(&quot;abc&quot;) name = &quot;auto&quot; driver.switch_to.frame(&quot;auto&quot;) 切换窗口 当测试页面同时出现2个或者以上窗口时候，而且新打开的window有name,可以使用driver.switch_to_window(winHandleID)来进行切换，如果窗口没有name，则需要通过定位浏览器句柄来区分浏览器窗口，然后再根据句柄进入不同的浏览器窗口 函数： driver.switch_to.window(winHandleID)-------------根据窗口name或句柄进入下一个窗口 driver.current_window_handle -------------获取当前窗口句柄 driver.window_handles -------------获取当前所有窗口的句柄 注意： 1.可以通过下标的方式定位到第二个窗口句柄 #获取当前窗口句柄 handle1 = driver.current_window_handle #点击下方的一元多宝 driver.find_element_by_link_text(&quot;一元夺宝&quot;).click() all_handles = driver.window_handles print(all_handles) handle2 = all_handles[1] #进入第二个窗口 driver.switch_to.window(handle2) 2.通过for循环的方式定位到下一个窗口句柄 #获得当前所有打开的窗口的句柄 all_handles = driver.window_handles #进入注册窗口 for handle in all_handles: if handle != handle1: driver.switch_to.window(handle2) 接受弹窗 driver.switch_to_alert().xx ---------接受弹出窗口 后接方法： text ``` text``` ：返回 alert/confirm/prompt 中的文字信息。 accept ```accept```：点击确认按钮。 dismiss ```dismiss ```：点击取消按钮，如果有的话 示例： driver = webdriver.Firefox() driver.maximize_window() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 打开搜索设置 #driver.find_element_by_xpath('//div[@id=&quot;lg&quot;]').click() driver.find_element_by_class_name('setpref').click() # 保存设置 driver.find_element_by_link_text(u'保存设置').click() time.sleep(3) # 接收弹窗 driver.switch_to_alert().accept() time.sleep(5) driver.quit() 鼠标悬停 from selenium.webdriver.common.action_chains import ActionChains …… # 注意：使用该方法需要先导入包 # 鼠标悬停相“设置”链接 link = driver.find_element_by_link_text(u'设置') ActionChains(driver).move_to_element(link).perform() #继续点击即可 下拉菜单的定位方式 先定位下拉框作为一个对象n，然后再根据value值定位该具体的选项。 # 选择省份 n=driver.find_element_by_id(&quot;province&quot;) n.find_element_by_xpath(&quot;//option[@value='10']&quot;).click() ","link":"https://liujinyang6.github.io/post/zi-dong-hua-ce-shi-selenium/"},{"title":"Appium教程","content":"一、Appium介绍 Appium是一款开源的自动化测试工具，其支持 iOS和安卓平台上的原生的，基于移动浏览 器的，混合的应用。 1、 使用 Appium进行自动化测试的好处 ​ Appium在不同平台中使用了标准的自动化 APIs，所以在跨平台时，不需要重新编译或者 修改自己的应用。 ​ Appium支持 Selenium WebDriver支持的所有语言，如 java、Object-C、JavaScript、Php、 Python、Ruby、C#、，或者 Perl 语言，更可以使用 Selenium WebDriver 的 Api。Appium支持任何一种测试框架。Appium实现了真正的跨平台自动化测试。（本文主要介绍 Python的用法） 2、Appium架构 ​ Appium 是一个用 Node.js编写的HTTP server，它创建、并管理多个 WebDriver sessions 来 和不同平台交互，如 iOS ，Android 等等. ​ Appium 开始一个测试后，就会在被测设备（手机）上启动一个 server ，监听来自 Appium server的指令. 每种平台像 iOS 和 Android 都有不同的运行、和交互方式。所以 Appium 会用某个桩程序“侵入”该平台，并接受指令，来完成测试用例的运行。 二、Appium安装 1、安装JDK，配置JDK 环境 打开计算机-&gt;系统属性-&gt;高级系统设置-&gt;环境变量-&gt;新建（系统变量），如图所示： 配置JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_181（根据自己的安装磁盘决定盘符） 配置Path： ;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin;追加进Path中； 配置CLASSPATH .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 验证一下JDK的环境是否配置好，win+r 输入cmd进入dos下输入java -version检查环境是否配置成功。 2、安装Android SDK，配置SDK环境 可以直接下载Android Studio，但是如果只是做自动化的话只需要下载Android SDK就行了。此处我们只下载SDK即可。 若本地无软件请去这里下载，下载地址：http://tools.android-studio.org/index.php/sdk/ 下载成功解压后配置Android SDK的环境。 新建ANDROID_HOME，环境变量内容就配置我们SDK的安装目录，此处我是：C:\\Program Files (x86)\\Android\\android-sdk，根据自己的实际（安装）情况决定。 如图所示： 打开安装好的SDK文件夹，双击SDK Manager，安装Tools下的Android SDK Platform-tools和Android SDK Build-tools，Android SDK Tools可以选择是否更新，建议直接更新。 Tools里面的三个必须勾选，版本无所谓。 注意：下方的镜像（API），随便选一个版本也可以选择多个版本安装，由于镜像比较大，所以有android真机的可以不下载镜像（切记），没有真机的同学才需要安装下方的api镜像，况且安卓本身的模拟器很难用，很卡，我们一般采用第三方模拟器，比如逍遥、蓝叠等来生成安卓模拟器，所以建议不用下载下方任何api 下方的extra全部勾选，安装 将%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools;%ANDROID_HOME%\\build-tools\\28.0.3 （注意此处我的是28.0.3，请根据自己下载的实际的版本镜像进行替换，位置在sdk安装目录下的build-tools下）加入环境变量Path中。 检查Android SDK的相关环境变量是否配置成功，win+r 打开运行对话框，输入cmd打开dos命令行窗口，在命令行窗口中输入adb --version，看到以下提示，说明配置成功，如果提示adb不是内部或外部命令，原因有两个： 1-sdk没有安装tools下的platform-tools； 2-sdk的相关环境变量没有配置正确。 3、安装Node.js 本地如果没有软件，请去下载地址：https://nodejs.org/en/ 选择大多数人下载的那个就行 1、下载获取到安装文件后，直接双击安装文件，根据程序的提示，完成nodejs的安装（一直下一步就行，可以将路径进行修改）。 将Node.js的安装路径（也就是node.exe文件所在的目录），此处我安装的是d盘，所以是D:\\Program Files\\nodejs追加到环境变量Path中。 检查一下环境是否配置好，在命令行中输入npm 4、安装.net framework（如果电脑上安装了或者安装了更高版本的则不需要此步骤） ​ 由于Appium是用.net开发的，所以安装之前需要安装.net framework，否则安装过程中会报错，官网下载：http://www.microsoft.com/zh-cn/download/details.aspx?id=30653 ​ 下载成功后直接点击安装即可。 5、安装Appium ​ 下载地址：https://bitbucket.org/appium/appium.app/downloads/ ​ 当前最新版本为 AppiumForWindows_1_4_16_1.zip ，注意这是一个 Windows 版本，如果你的电脑为MAC请下载 appium-1.5.3.dmg 。虽然你已经看到了这些下载包，但我不保证你能下载的下来。 ​ 我们以 Windows 为例，将下载的 AppiumForWindows.zip 进行解压，点击 appium-installer.exe 进行安装。 ​ 在Path中配置appium的环境变量，将安装的Appium文件夹所在目录\\Appium\\node_modules.bin添加进path cmd打开命令行窗口，输入appium-doctor ，出现以下提示，All Checks were successful ,说明环境配置成功。 六、安装appium - python - client（这步很重要，目的是需要将Python与appium关联起来) ​ 首先需要安装Python3.x，进行环境配置 ​ cmd打开命令行窗口，输入：pip install Appium-Python-Client，提示成功就可以了，我这边是已经安装过了。 如果提示以下错误: 则通过更换国内安装源和设置超时时间可以解决。 在pip install XXX命令的后面加上 --default-timeout=100 -i https://pypi.tuna.tsinghua.edu.cn/simple即可。 有时候只需更换国内安装源便可解决问题。如下图所示: 至此，appium环境搭建成功！！！ 三、启动真机或模拟器准备工作 启动目标app前先确定以下条件是否满足： 1.appium服务器是否正常运行 双击该软件appium-desktop，启动appium服务器 启动后： 点击start Server，启动appium服务器 看到以上图形，代表服务启动成功。 2.手机/模拟器是否已连接，且能在adb中查看到 通过dos窗口输入adb devices查看，下图为模拟器的例子 adb 命令进行连接模拟器， 命令：adb connect 127.0.0.1:port----（此处的端口由模拟器决定，不同的模拟器默认端口不同），如下图: 各种模拟器默认端口： 夜神安卓模拟器 62001 逍遥安卓模拟器 21503 BlueStacks (蓝叠安卓模拟器) 5555 雷电安卓模拟器 5555 天天安卓模拟器 5037 网易MuMu (安卓模拟器) 7555 安卓模拟器大师 54001 Genymotion 5555 如果是安卓真机，需要在设置里面进入关于手机，里面连击版本号，会提示手机已进入开发者模式，在设置中查找开发者选项，开启USB调试，再次通过数据线连接手机即可。 注意：模拟器和真机不要同时连接，以免产生影响 3.被测软件是否已经安装到真机/模拟器上 将目标apk安装到目标机器上，如果是模拟器，如下图： 点击此处，找到目标apk，即可安装到模拟器 以上3个条件满足，我们开始编写代码，来启动app 四、appium启动 此处我们以模拟器上的今日头条的apk为例 # 导入appium包 from appium import webdriver import time # 设置启动参数 def startUp(): print(&quot;启动中......&quot;) # 启动参数设置成dict数据格式 desire_caps = { &quot;deviceName&quot;: &quot;127.0.0.1:21503&quot;, &quot;platformName&quot;: &quot;Android&quot;, &quot;platformVersion&quot;: &quot;5.1.1&quot;, &quot;appPackage&quot;: &quot;com.ss.android.article.news&quot;, &quot;appActivity&quot;: &quot;com.ss.android.article.news.activity.MainActivity&quot;, &quot;noReset&quot;: True, &quot;unicodeKeyboard&quot;: True } # 启动app（第一个参数输入appium server的服务器地址，默认端口为4723，第二个参数输入启动参数） driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub', desire_caps) print(&quot;启动完成，等待3秒。&quot;) time.sleep(3) # 定位目标元素，进行操作 # 关闭app if __name__ = '__main__': startUp() &quot;deviceName&quot;: 通过adb devices获取，此处是模拟器所以填写的是ip和port &quot;platformName&quot;: 被测系统决定是Android还是ios, &quot;platformVersion&quot;: 通过查看被测系统的设置查看, &quot;appPackage&quot;: 通过aapt dump badging xxx.apk | findstr package获取, &quot;appActivity&quot;: 通过aapt dump badging xxx.apk | findstr activity获取, 操作方法： 1、 将目标apk放在一个已知目录下 2、 进入dos环境，进入到该目录下，输入 aapt dump badging jinritoutiao.apk |findstr package ----用来查看package aapt dump badging jinritoutiao.apk |findstr activity ----用来查看activity 如果是linux或者mac 则把findstr换成grep 总结： ​ aapt dump badging D:\\XXX.apk: 获取安装包的所有信息 adb devices: 查看手机是否连接到电脑，可以看到设备名称 ​ 其他： ​ adb shell dumpsys activity：查看当前运行的是哪个activity,运行的一些进程等 ​ adb shell pm list packages：列出所有的包名。 ​ adb shell dumpsys package：列出所有的安装应用的信息 ​ adb shell dumpsys package com.android.XXX：查看某个包的具体信息 ​ adb logcat | grep ActivityManager：查看当前正在运行的Activity 详细操作： 1、 连接真机或者模拟器（此处以真机为例） ​ 连接手机时注意选择手机的开发者模式，cmd打开命令行窗口，输入adb devices获取到设备的deviceName。 2.获取Activity ​ cmd打开命令行窗口，输入aapt dump badging D:\\XXX.apk（xxx指安装包名，D:\\是指路径）直接查看需要测试app安装包的具体信息。 标记的就是包名，继续往下拖拽，可以找到activity的信息。 这里的红圈就可以看到activity的信息。这两个值，在appium脚本中都需要提前获取到，所以需要提前介绍这个获取方法。如果你觉得在cmd里面不好看，你可以把cmd信息导出到一个txt文件，例如 aapt dump badging shoujibaidu.apk &gt; 123.txt 回车后，会在桌面生成一个123.txt文件，你可以打开，通过查询找到这些信息。通过上面的方法，只要我们有android SDK环境，那么我们就可以获取到任意一个包的包名和Activity信息。 填好一下参数，参数说明如下： 能力 描述 值 appPackage App的包名，通过aapt dumpsys badging xxx.apk获取 例如：'appPackage': 'com.jyibb.shell_customer', platformName 使用哪个移动操作系统平台 例如：'platformName': 'Android' platformVersion 移动操作系统版本 例如：'platformVersion': '5.1' deviceName 使用的移动设备或模拟器的名称，通过adb devices获取 例如：'deviceName':'8TB6V4ZPZ54LPJ5P' app 如果为第一次启动则需要通过该参数指定app安装包的位置，一般为绝对路径 例如：'app': ‘D:\\shell_customer-debug.apk' newCommandTimeout 在假定客户端退出并结束会话之前，Appium将等待来自客户端的新命令（以秒为单位） 例如 60 appActivity 通过aapt dumpsys badging xxx.apk获取 例如 'appActivity': 'com.jyibb.module_launch_customer.SplashActivity', udid 连接的物理设备的唯一设备标识符，此参数为ios特有参数 例如 ：'udid':'1ae203187fc012g' noReset 在此会话之前不要重置应用程序状态。 true， false fullReset 执行完整的重置。 true， false unicodeKeyboard 解决输入中文的问题，否则不能用sendkeys输入中文 例如， ‘unicodeKeyboard':'True' resetKeyboard 将键盘隐藏起来，默认true true， false 五、 appium元素定位 1、常用识别元素的工具 uiautomator：Android SDK自带的一个工具，在sdk的tools目录下（一定关闭appium-desktop的自带的定位工具后打开，否则连接不上模拟器/真机 ） 找到sdk下的tools里面的uiautomatorviewer.bat ​ ​ 双击打开后界面是： ​ ​ 点击后，可以连上模拟器和真机 ​ ​ 以头条app为例 ​ appium-desktop优先使用desktop 启动appium-desktop，点击服务器右上角的查找按钮，界面如下 ​ 点击启动后： 使用介绍： 使用方法： monitor：Android SDK自带的一个工具，在tools目录下，此工具主要用来监控Android手机的运行情况，比如线程、堆内存，日志输出、等等。 2.元素定位 1.格式：find_element_by_定位方式(value) 通过id定位 # 取resource-id的值 driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/azo&quot;) # 也可以直接用id后面的内容 driver.find_element_by_id(&quot;azo&quot;) 通过class_name定位 # 取class的内容 driver.find_element_by_class_name(&quot;android.widget.RelativeLayout&quot;) 通过xpath定位 # 取xpath得内容 driver.find_element_by_xpath(&quot;//android.widget.LinearLayout[1]/android.widget.XXX&quot;) 通过text定位 # 需要使用uiautomator的定位方式，使用text的内容 driver.find_elements_by_android_uiautomator(&quot;new UiSelector().text(\\&quot;+关注\\&quot;)&quot;) 使用这里需要注意一下，通过text定位的结果是个list，不能直接click。所以如果要点击需要取数组的值，比如下面是点击找到的第一个元素 driver.find_elements_by_android_uiautomator(&quot;new UiSelector().text(\\&quot;+关注\\&quot;)&quot;)[0].click() 通过css_selector定位(webview) # 只适用于webview的html页面，继承自webdriver，与pc版本的UI测试一致 driver.find_element_by_css_selector() 通过link_text定位(webview) # 只适用于webview容器中的html页面，继承自webdriver，与pc版本的UI测试一致 driver.find_element_by_link_text() 通过name定位(webview) # webview容器中的html页面可以用name定位，native并没有name属性 driver.find_element_by_name() 2.定位元素的另一种写法：find_element(by,value) find_element_by_方式(value)实际调用的都是find_element(by,value) 需要导入这个包：from selenium.webdriver.common.by import By # 例如：定位id为ag2的元素 # 方式一： driver.find_element_by_id(&quot;ag2”) # 方式二： driver.find_element(By.ID,&quot;ag2&quot;) # 这个操作的好处是可以直接把操作的by和value放到一个元组里，然后调用通用方法来传参获得元素结果 cateid=(By.ID,&quot;ag2&quot;) driver.find_element(*cateid).click() by的操作可以是 By.ID 相当于by_id By.CLASS_NAME 相当于by_class_name By.XPATH 相当于by_xpath By.NAME 相当于by_name By.TAG_NAME 相当于by_tag_name By.CSS_SELECTOR 相当于by_css_selector By.LINK_TEXT 相当于by_link_text By.android_uiautomator 相当于by_android_uiautomator() 查看具体写法可以关注https://www.cnblogs.com/cnkemi/p/9185253.html 3.find_elements_by_定位方式(value)返回元素数组 用法与find_element_by_方式(value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果 例如：通过class_name定位到多个元素，我想点击第一个元素 driver.find_elements_by_class_name(&quot;android.widget.RelativeLayout”)[0].click() 4.返回元素数组的另一种写法：find_elements(by,value) 用法与find_element(by,value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果 例如：通过class_name定位到多个元素，我想点击第一个元素 driver.find_elements(By.CLASS_NAME,&quot;android.widget.RelativeLayout&quot;)[0].click() 5.通过元素定位元素 可以先找到某个元素，然后再进一步定位元素 find_element_by_class_xpath(“xxx”).find_element_by_name(“yyy&quot;) 6.Xpath定位详解 手工编写： 纯标签路径：position 绝对路径：/html/body/div/div[3]/div[2]/form/input 相对路径：//div[2]/form/input 标签和属性结合:attribute 语法：//标签名[@属性=属性值] 例如： //input[@id='word'] //form/input[@id='word']----标签可以有多个，也可以只有一个 //div[@class='hotwords']/a[1]---也可利用上层标签的属性进行定位 示例： driver = webdriver.Firefox() driver.implicitly_wait(5) driver.maximize_window() driver.get('http://127.0.0.1:8888/iwebshop/') driver.find_element_by_xpath(&quot;//div[@class='hotwords']/a[1]&quot;).click() time.sleep(5) driver.quit() 7.CSS定位详解 层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。 使用Firebug复制： 右击目标对象，使用Firebug查看元素，在其高亮区域右击选择复制css路径 手工编写 标签和属性组合：标签名[属性名=属性值] ----标签名可以多个，多个时需要用空格隔开：form input.text ----属性可以随意：input[type='text']&quot; 例子：Input[class=’xxx’] 注意：class/id除了可以采用[属性=属性值]的写法，还可以用专用写法 通过class编写：标签名.class的属性值 通过id编写：标签名#id的值 组合 ：标签名#id值.class值 示例： driver = webdriver.Firefox() driver.implicitly_wait(5) driver.maximize_window() driver.get('http://127.0.0.1:8888/iwebshop/') driver.find_element_by_css_selector(&quot;div.brand div.cont ul li a img&quot;).click() time.sleep(8) driver.quit() 六、元素操作 找到元素后可以对元素进行的操作，例如上面讲的进一步定位元素 1.click() //点击操作 也可以用tap实现点击操作 driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click() 2.clear() //清空输入框内容 driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ij&quot;).clear() 3.send_keys(xx) //输入框内输入内容 driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ij&quot;).send_keys(&quot;test content&quot;) 4.text //获得元素的text内容 print(driver.find_element_by_xpath(&quot; //android.widget.LinearLayout[1]//xxx&quot;).text) 七、触摸操作 1.driver.tap([坐标]，持续点击时间) 除了定位到元素的点击外，也可以通过tab实现坐标的点击 driver.tap() 2.TouchAction(driver) TouchAction对象包含（tap）、press（短按）、move_to（滑动到某个坐标）等方法 通过TouchAction对象，添加tap、move_to等操作，然后perform()执行，可以实现解锁屏幕等功能 规范中的可用事件有： 短按 (press) 释放 (release) 移动到 (moveTo) 点击 (tap) 等待 (wait) 长按 (longPress) 取消 (cancel) 执行 (perform) 示例： 一个多次滑屏的例子： action = TouchAction(driver) action.press(x=220,y=700).move_to(x=840, y=700).move_to(x=220, y=1530).move_to(x=840, y=1530).release().perform() # 可以通过wait()等待操作 action.press(x=220,y=700).move_to(x=840, y=700).wait(1).perform() 3.MultiAction() 多点触控 通过MultiAction().add()添加多个TouchAction操作，最后调用perform()一起执行这些操作 action0 = TouchAction().tap(el) action1 = TouchAction().tap(el) MultiAction().add(action0).add(action1).perform() 4.driver.swipe(x1, y1, x2, y2,duration) 从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间（滑动的坐标不能超过屏幕的宽高） 可以通过driver.get_window_size()命令获得窗口高和宽，结果为{'width': 1080, 'height': 1776} 一个向上下左右滑动屏幕的例子如下： # 获得屏幕大小宽和高 def getSize(self): x = self.driver.get_window_size()['width'] y = self.driver.get_window_size()['height'] return (x,y) # 向上滑动屏幕 def swipeUp(self, t=1000): l = getSize() x1 = int(l[0] * 0.5) y1 = int(l[1] * 0.25) y2 = int(l[1] * 0.75) self.driver.swipe(x1, y1, x1, y2, t) # 向下滑动屏幕 def swipeDown(self, t=1000): l = getSize() x1 = int(l[0] * 0.5) y1 = int(l[1] * 0.75) y2 = int(l[1] * 0.25) self.driver.swipe(x1, y1, x1, y2, t) # 向左滑动屏幕 def swipeLeft(self, t=1000): l = getSize() y1 = int(l[1] * 0.5) x1 = int(l[0] * 0.25) x2 = int(l[0] * 0.75) self.driver.swipe(x1, y1, x2, y1, t) # 向右滑动屏幕 def swipeRight(self, t=1000): l = getSize() y1 = int(l[1] * 0.5) x1 = int(l[0] * 0.75) x2 = int(l[0] * 0.25) self.driver.swipe(x1, y1, x2, y1, t) # 调用向下滑动的方法 swipeDown(driver) 八、系统按键事件 press_keycode(AndroidKeyCode) 例如：点击home键，home键的KeyCode是3 driver.press_keycode(3) 键名 描述 键值 KEYCODE_CALL 拨号键 5 KEYCODE_ENDCALL 挂机键 6 KEYCODE_HOME 按键Home 3 KEYCODE_MENU 菜单键 82 KEYCODE_BACK 返回键 4 KEYCODE_SEARCH 搜索键 84 KEYCODE_CAMERA 拍照键 27 KEYCODE_FOCUS 拍照对焦键 80 KEYCODE_POWER 电源键 26 KEYCODE_NOTIFICATION 通知键 83 KEYCODE_MUTE 话筒静音键 91 KEYCODE_VOLUME_MUTE 扬声器静音键 164 KEYCODE_VOLUME_UP 音量增加键 24 KEYCODE_VOLUME_DOWN 音量减小键 25 九、driver的一些其他操作 1.reset() 重置app：这时候driver会重置，相当于卸载重装应用。所以本地缓存会失效 driver.reset() 2.scroll(起始元素，结束元素) 滑动屏幕：从起始元素滑动到结束元素 driver.scroll(origin_el,destination_el) 3.driver.page_source 获取当前页面内的所有元素 这可以用来判断元素是否存在，例如：assert &quot;发布成功&quot; in driver.page_source 4.driver.is_app_installed(package_name) 检查app安装情况（返回true或false） driver.is_app_installed(package_name) 5.driver.install_app(&quot;x:/xxx.apk&quot;) 安装app driver.install_app(&quot;x:/xxx.apk&quot;) 6.driver.remove_app(package_name) 卸载app driver.remove_app(package_name) 7.driver.open_notifications() 打开通知栏 driver.open_notifications() 8.driver.close_app() 关闭app driver.close_app() 9.driver.launch_app() 启动app driver.launch_app() 10.driver.shake 模拟摇晃设备 driver.shake 11.driver.resetApp() 重置应用 driver.resetApp() 12.driver.find_element_by_id(activity) 检查是否存在某个activity(未找到则返回异常） driver.find_element_by_id(activity) 13.self.driver.current_activity 获取当前的activity activity = self.driver.current_activity print(u&quot;当前的activity是:&quot;, activity) 14.driver.wait_activity(activity, x, y) 等待activity启动直到x秒超时，每隔y秒扫描一次 driver.wait_activity(activity, x, y) 15.driver.background_app(x) 将app置于后台运行x s 注意：测试发现置于后台数秒后变为前台时，将是重新启动app，进入首页，而不是切入后台时的界面 driver.background_app(x) 16.driver.available_ime_engines 打印可用的输入法 IME_LISE = driver.available_ime_engines print(IME_LISE) 17.driver.activate_ime_engine(IME_LISE[-1]) 激活安卓设备中的指定输入法(设备可用输入法可以从“available_ime_engines”获取)&quot; driver.activate_ime_engine(IME_LISE[-1]) 18.driver.is_ime_active() 检查设备是否有输入法服务活动,返回True/False driver.is_ime_active() 19.driver.hide_keyboard() 退出键盘 driver.hide_keyboard() 十、自动化测试用例的实现 以今日头条发微头条为例： 前提：启动头条app，且是登录状态 打开首页，点击发表按钮 点击微头条，输入内容 点击发布 检查是否发表成功（数据库/页面） 自动化： 定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入） 定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入） 定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入） 断言（接口状态码，数据库字段，app页面） ","link":"https://liujinyang6.github.io/post/appium-jiao-cheng/"},{"title":"DDT框架","content":"​ ​ 数据驱动的单元测试是为数据源中的每一行重复运行的一种单元测试。数据驱动的单元测试的常用情况是使用多个输入值测试 API。不是编写调用 API 的多个单元测试（每个单元测试均具有一组新的输入），也不是在单元测试中创建一个数组并使用循环代码，而是可以编写执行 API 的单个单元测试方法。然后可以从数据库表的行中进行数据检索以便传递给该测试方法的连续调用。可以使用此技术测试由不同用户（每个用户具有不同角色）使用的应用程序。对于每个用户，数据源中的一行将根据角色指示预期响应。然后，该测试将通过针对每个用户运行功能，对该应用程序进行测试，并验证产生的响应是否与预期响应一致。 ​ 在测试工作中，针对某一API接口，或者某一个用户界面的输入框，需要设计大量相关的用例，每一个用例包含实际输入的各种可能的数据。通常的做法是，将测试数据存放到一个数据文件里，然后从数据文件读取，在脚本中循环输入测试数据，并对结果进行验证。 ​ ddt是结合unittest框架来工作的，所以要先具备unittest框架的知识。 使用步骤 1.导入ddt包 2.用装饰器装饰@ddt 3.传入参数，执行 传参示例 传参方式一：单个传参 # 单个传参 import unittest from ddt import ddt,data,unpack @ddt class MyTestCase1(unittest.TestCase): # 2,3,4会分别按照执行次数传入，比如第一次执行方法传入2，第二次执行方法传入3,第三次...... @data(2, 3, 4) def test_normal(self, value): print(value) self.assertEqual(value, 2) if __name__ == '__main__': unittest.main() 传参方式二：元组、列表、字典传参 # 元组、列表、字典传参 import unittest from ddt import ddt,data,unpack @ddt class MyTestCase2(unittest.TestCase): # 会依次按照执行次数传入，比如第一次执行该方法传入（1，2），第二次传入（2，3） @data((1, 2), (2, 3)) @unpack # 只有需要进行分发参数的时候才需要添加。1分发给value1，2分发给value2 def test_tuple(self, value1, value2): print(&quot;tuple:&quot;,value1, value2) self.assertEqual(value2, value1+1) @data([1, 2], [2, 3]) @unpack def test_list(self, value1, value2): print(&quot;list:&quot;,value1, value2) self.assertEqual(value2, value1+1) @data({'value1':1, 'value2':2}, {'value1':2, 'value2':3}) @unpack # 入参参数名必须和字典key值一致，否则会报错 def test_dict(self, value1, value2): print(&quot;dictionary:&quot;,value1, value2) self.assertEqual(value2, value1+1) if __name__ == '__main__': unittest.main() 传参方式三：json文件传参 # 传入json import unittest from ddt import ddt,data,unpack,file_data @ddt class MyTestCase3(unittest.TestCase): @file_data('E:\\\\test.json') def test_file(self, value): print(&quot;json file:&quot;,value) if __name__ == '__main__': unittest.main() ","link":"https://liujinyang6.github.io/post/ddt-kuang-jia/"},{"title":"unittest教程","content":"Python中有一个自带的单元测试框架是unittest模块，用它来做单元测试，它里面封装好了一些校验返回的结果方法和一些用例执行前的初始化操作。在说unittest之前，先说几个概念： TestCase 也就是测试用例 TestSuite 多个测试用例集合在一起，就是TestSuite TestLoader是用来加载TestCase到TestSuite中的 TestRunner是来执行测试用例的,测试的结果会保存到TestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息 下面我们分别来解释这四个概念的意思，先来看一张unittest的静态类图。 一个TestCase的实例就是一个测试用例。什么是测试用例呢？就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)。单元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证。 而多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite。 TestLoader是用来加载TestCase到TestSuite中的，其中有几个loadTestsFrom__()方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例。 TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法。 测试的结果会保存到TextTestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息。 一个class继承了unittest.TestCase，便是一个测试用例，但如果其中有多个以 test 开头的方法，那么每有一个这样的方法，在load的时候便会生成一个TestCase实例，如：一个class中有四个test_xxx方法，最后在load到suite中时也有四个测试用例。 在每一个测试用例中可以重写 以下函数 : setUp()该测试用例执行前的设置工作、 tearDown()该测试用例执行后的清理工作、 setUpClass()所有测试用例前的设置工作、 tearDownClass()所有测试用例执行后的清洗工作 在每一个测试用例中可以通过skip，skipIf，skipUnless装饰器跳过某个测试函数，或者用TestCase.skipTest方法跳过测试函数。 @unittest.skip() @unittest.skipIf() @unittest.skipUnless() 到这里unittest的整个流程就清楚了： 写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中。 我们通过命令行或者unittest.main()执行时，main会自动调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。 加个说明： 1、TestLoader加载TestCase到TestSuite可以通过TestSuite实例对象的addTest()和addTests()方法向suite中添加case或suite 2、在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）。 3、在进行测试时可以传递verbosity参数，用以控制执行结果的输出，0 是简单报告、1 是一般报告、2 是详细报告。 被测方法： 这里我们随意写几个业务函数，表示我们将要进行测试的功能函数。将功能函数文件存储成myfun.py # 被测函数示例 # 保存为mufun.py def add(a, b): return a + b def minus(a, b): return a - b def multi(a, b): return a * b def divide(a, b): return a / b TestCase测试用例: 我们通过测试用例用代码来实现每一个测试的详细过程和针对测试目标要测试的内容。同目录下创建test_myfun.py # 测试用例示例 class TestMyFun(unittest.TestCase): # TestCase基类方法，所有case执行之前自动执行 @classmethod def setUpClass(cls): print(&quot;这里是所有测试用例前的准备工作&quot;) # TestCase基类方法，所有case执行之后自动执行 @classmethod def tearDownClass(cls): print(&quot;这里是所有测试用例后的清理工作&quot;) # TestCase基类方法，每次执行case前自动执行 def setUp(self): print(&quot;这里是一个测试用例前的准备工作&quot;) # TestCase基类方法，每次执行case后自动执行 def tearDown(self): print(&quot;这里是一个测试用例后的清理工作&quot;) @unittest.skip(&quot;我想临时跳过这个测试用例&quot;) def test_add(self): # 测试add()函数 self.assertEqual(3, add(1, 2)) self.assertNotEqual(3, add(2, 2)) def test_minus(self): # 测试minus()函数 self.skipTest(&quot;跳过这个测试用例&quot;) self.assertEqual(1, minus(3, 2)) def test_multi(self): # 测试multi()函数 self.assertEqual(6, multi(2, 3)) def test_divide(self): # 测试divide()函数 self.assertEqual(2, divide(6, 3)) self.assertEqual(2.5, divide(5, 2)) if __name__ == &quot;__main__&quot;: unittest.main(verbosity=2) 注意： skip装饰器一共有三个 unittest.skip(reason)、unittest.skipIf(condition,reason)、unittest.skipUnless(condition,reason)，其中skip是无条件跳过，skipIf是当condition为True时跳过，skipUnless是当condition为False时跳过。 每个测试方法必须以 test 开头，否则是不被unittest识别的。其实每一个test开头的方法都会加载为独立的测试用例。 在unittest.main()中加 verbosity 参数可以控制输出的错误报告的详细程度，默认是 1；如果设为 0，则不输出每一用例的执行结果；如果参数为2则表示输出详细结果。 TestSuite测试套件 TestSuite用来控制多个测试用例和多个测试文件之间的测试顺序。（这里的示例中的几个测试方法并没有一定关系，但之后你写的用例可能会有先后关系，需要先执行方法A，再执行方法B），我们添加到TestSuite中的case是会按照添加的顺序执行的。 一、创建测试套件 语法：1.实例化、2.调用 addTest()方法 # 1.实例化Testsuite类 # 注：TestSuite()主要用来创建测试套件集合 suite = unittest.TestSuite() # 2.调用addTest()添加测试方法 # 添加语法：suite.addTest(文件名.类名(‘类中的方法名’)) suite.addTest(TestCount('test_add')) # 调用TestSuite类中的addTest：suite.addTest(类名(‘类中的方法名’)) # 执行顺序是按照添加的顺序执行，先添加的先执行 注：test_add是unittest脚本中的被测方法，如果是添加被导入模块中的方法，则需要指定哪个文件名。 suite.addTest(文件名.类名(‘类中的方法名’)) 二、 运行测试套件TextTestRunner() 语法：1.实例化、 2.调用run()方法 # 1.实例化TextTestRunner类 runner = unittest.TextTestRunner() # 2.调用Testsuite类中的addTest方法 runner.run(suite) 注：TextTestRunner()主要用来运行测试套件 坑：使用Unittest做单元测试，addTest（）单个case的时候却执行全部的case 首先造成这个结果的原因是pycharm配置问题 测试代码： import unittest class Testadd(unittest.TestCase): def setUp(self): self.a = 20 self.b = 10 def test_add(self): result = self.a + self.b self.assertEqual(result,30) def test_sub(self): result = self.a -self.b self.assertEqual(result,10) if __name__ == &quot;__main__&quot;: suite = unittest.TestSuite() suite.addTest(Testadd(&quot;test_add&quot;)) runner = unittest.TextTestRunner() runner.run(suite) pycharm执行结果： 命令行执行结果： 问题解决： 点击pycharm的右上角下拉菜单，点击Edit configurations 将Python tests里的对应文件的py.test for...或者unittest for...的文件删除（选中后点击左上角的减号） 点击+，在下拉菜单中选择Python，然后在右边的script path里...选中所要运行的文件 最后点击ok即可，再在所要运行的文件处（最好是main处）点击右键就会发现run unittest变成了run 再次在pycharm中运行，well done 总结： 执行unittest in demoSingle就会运行全部case 而如果运行py文件本身就会只运行addsuite添加的用例 三、单元测试框架实现模块整合---discover方法 遍历所有测试脚本实现整合 使用测试套件单独管理全部功能的用例，利用测试套件整合 TestLoader 该类根据各种标准负责加载测试用例，并返回给测试套件。正常情况下没有必要创建这个类的实例。unittest 提供了可以共享了 defaultTestLoader 类，可以使用其子类和方法创建实例，所以我们可以使用其下面的 discover()方法来创建一个实例。 既： discover = unittest.defaultTestLoader.discover(start_dir，pattern='test*.py'，top_level_dir=None) discover = unittest.TestLoader().discover(start_dir，pattern='test*.py'，top_level_dir=None) #运行方法同上(上述方法2选1) runner = unittest.TextTestRunner() runner.run(discover) 找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。 start_dir ：要测试的模块名或测试用例目录。（采用双斜线或目录前加r） pattern='test*.py'：表示用例文件名的匹配原则。星号“*”表示任意多个字符。 top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是在该目录下则需要分别指定），默认为 None。 注：discover发现的py文件不能控制先后顺序，只能通过文件名字的assccii码值来判断先后运行顺序，所以文件命名的时候可以通过testA……等来定义 总结：单元测试的执行方法一共有3种： 第一种：通过unittest.main()加载全部test开头的用例并自动执行 第二种：通过添加测试套件的方法addTest，然后运行添加好的测试套件 第三种：通过testloader来加载指定目录下的test开头的用例，运行添加好的discover 测试报告 1、通过打开/写入文件，编写测试报告 ​ 自己完成 2、通过 HTMLTestRunner.py 来生成测试报告。 HTMLTestRunner 是 Python 标准库的 unittest 单元测试框架的一个扩展。它生成易于使用的 HTML 测试报告。 HTMLTestRunner是在 BSD 许可证下发布。 HTMLTestRunner 首先要下 HTMLTestRunner.py 文件，下载地址： http://tungwaiyip.info/software/HTMLTestRunner.html HTMLTestRunner.py 本是一个.py 文件，将它放到 Python 安装目录下即可调用。 # 语法： # 首先引入HTMLTestRunner包 import HTMLTestRunner # 用法： # 1----------定义个报告存放路径 filename = 'C:\\\\test_object\\\\report\\\\result.html' # 2----------定义一个文件名，以写方式打开 fp = open(filename, 'wb') # 3----------定义测试报告 runner =HTMLTestRunner.HTMLTestRunner( stream=fp, title=u'百度搜索测试报告', description=u'用例执行情况：') # 4----------运行测试用例 runner.run(suite) # 5----------关闭报告文件 fp.close() ","link":"https://liujinyang6.github.io/post/unittest-jiao-cheng/"},{"title":"python读写excel文件","content":"用xlrd和xlwt读写excel 首先下载安装xlrd和xlwt这两个库 使用xlrd读取excel # 导入包 import xlrd # 1、打开excel readbook = xlrd.open_workbook(r'\\test\\canying.xlsx') # 2、获取读入的文件的sheet sheet = readbook.sheet_by_index(1)#索引的方式，从0开始 sheet = readbook.sheet_by_name('sheet2')#通过名字定位sheet页 allsheetnames = readbook.sheet_names()#返回所有sheet页名字组成的列表 # 3、获取sheet的最大行数和列数 nrows = sheet.nrows#行 ncols = sheet.ncols#列 # 4、获取某个单元格的值 lng = sheet.cell(x,y) lng = sheet.cell(0,0).value#获取1行1列的表格值，从0开始计数 lat = sheet.cell(1,4).value#获取2行5列的表格值，从0开始计数 # 5、获取某行/某列的值 row_value = sheet.row_values(x) #获取x行的值，从0开始计数 col_value = sheet.col_values(y) #获取y列的值，从0开始计数 使用xlutils.copy写excel # 导入前，先导入xlrd，需要依赖这个包 from xlutils.copy import copy # 1-读取源excel中的所有数据（复制对象） rb = xlrd.open_workbook(excel_dir + '\\\\' + 'data.xls') # 2-复制读取的源excel对象 wb = copy(rb) # 3-通过get_sheet()获取复制对象的sheet页 ws = wb.get_sheet(2) # 4-对sheet页进行写入(传入x和y坐标，和具体写入的value) ws.write(id,2,real) ws.write(id,3,status) # 5-保存excel（具体的excel路径+名称） wb.save(self.excel_dir + '\\\\' + 'data.xls') 注意：运行代码时要关闭excel，否则会报错 使用openpyxl库读写excel ​ xlrd和xlwt处理的是xls文件，单个sheet最大行数是65535，如果数据量超过65535就会遇到：ValueError: row index was 65536, not allowed by .xls format。 ​ 如果有更大需要的，建议使用openpyxl函数，最大行数达到1048576。 # 导入包 import openpyxl # 打开excel file_path = r'D:\\work\\testdata.xlsx' inwb = openpyxl.load_workbook(file_path) # 读取文件 # 获取打开的excel的sheet内容 sheetnames = inwb.get_sheet_names() # 获取所有sheet页的name ws = inwb.get_sheet_by_name(sheetnames[0]) # 按照name获取第一个sheet页的内容 # 获取sheet的最大行数和列数 rows = ws.max_row cols = ws.max_column # 获取某个单元格的值 ws.cell(1, 1).value # 打开将写的表并添加sheet outwb = openpyxl.Workbook() # 打开一个将写的文件 outws = outwb.create_sheet(index=0) # 在将写的文件创建一个新的sheet # 保存 saveExcel = r'D:\\work\\new.xlsx' outwb.save(saveExcel) # 一定要记得保存 注意：最后一定要记得保存，否则就前功尽弃喽😲 ","link":"https://liujinyang6.github.io/post/python-du-xie-excel-wen-jian/"},{"title":"Python读取config.ini文件","content":"读取步骤： 1.导入configparser import configparser 2.实例化一个configparser对象，读取目标配置文件内容 # 1.实例化configparser对象 conf = configparser.ConfigParser() # 2.获取目标.ini文件路径 file_path = os.path.dirname(‘xxxini文件路径’)+&quot;\\\\config.ini&quot; # 3.读取目标文件内的内容(section)，当有中文的时候使用encoding conf.read(file_path,encoding=&quot;utf-8-sig&quot;) config.ini文件格式 获取文件内的所有section sections = conf.sections() print('获取配置文件所有的section', sections) 获取xx section下的所有option options = conf.options('mysql') print('获取指定section下所有option', options) 获取xx section下的所有键值对 items = conf.items('mysql') print('获取指定section下所有的键值对', items) 获取xx section下的某个option value = conf.get('mysql', 'host') print('获取指定的section下的option', value) ","link":"https://liujinyang6.github.io/post/python-du-qu-config-ini-wen-jian/"},{"title":"常用的邮箱服务器","content":"一、常用的邮箱服务器地址 阿里云邮箱（mail.aliyun.com）: POP3服务器地址:pop3.aliyun.com（SSL加密端口：995；非加密端口：110） SMTP服务器地址:smtp.aliyun.com（SSL加密端口：465；非加密端口：25） IMAP服务器地址：imap.aliyun.com（SSL加密端口：993；非加密端口：143） 谷歌邮箱(google.com)： POP3服务器地址:pop.gmail.com（SSL启用端口：995） SMTP服务器地址:smtp.gmail.com（SSL启用端口：587） 新浪邮箱（sina.com）: POP3服务器地址:pop3.sina.com.cn（端口：110） SMTP服务器地址:smtp.sina.com.cn（端口：25） Tom邮箱（top.com）: POP3服务器地址:pop.tom.com（端口：110） SMTP服务器地址:smtp.tom.com（端口：25） 网易邮箱（163.com）: POP3服务器地址:pop.163.com（端口：110） SMTP服务器地址:smtp.163.com（端口：25） 126邮箱: POP3服务器地址：pop.live.com（端口：995） SMTP服务器地址:smtp.126.com（端口：25） 雅虎邮箱（yahoo.com）: POP3服务器地址:pop.mail.yahoo.com SMTP服务器地址:smtp.mail.yahoo.com 雅虎中国（yahoo.com.cn）: POP3服务器地址:pop.mail.yahoo.com.cn（端口：995） SMTP服务器地址:smtp.mail.yahoo.com.cn（端口：587） 雅虎邮箱POP3的SSL不启用端口为110，POP3的SSL启用端口995；SMTP的SSL不启用端口为25，SMTP的SSL启用端口为465。 Foxmail邮箱（foxmail.com）： POP3服务器地址:POP.foxmail.com（端口：110） SMTP服务器地址:SMTP.foxmail.com（端口：25） QQ邮箱（mail.qq.com） POP3服务器地址：pop.qq.com（端口：110） SMTP服务器地址：smtp.qq.com（端口：25） SMTP服务器需要身份验证。 搜狐邮箱（sohu.com）: POP3服务器地址:pop3.sohu.com（端口：110） SMTP服务器地址:smtp.sohu.com（端口：25） HotMail邮箱（hotmail.com）： POP3服务器地址：pop.live.com（端口：995） SMTP服务器地址：smtp.live.com（端口：587 移动139邮箱: POP3服务器地址：POP.139.com（端口：110） SMTP服务器地址：SMTP.139.com(端口：25) 中华网邮箱（china.com）: POP3服务器地址:pop.china.com（端口：110） SMTP服务器地址:smtp.china.com（端口：25） 以上便是常用邮箱SMTP服务器地址大全。可能还有些邮箱木有收集到。我们在设置代收发邮件软件时候，在POP3服务器地址及SMTP服务器地址处，只需要按照以上邮箱对应填写即可。 二、如何打开POP3/SMTP/IMAP功能？ 为了保障用户邮箱的安全，QQ邮箱设置了POP3/SMTP/IMAP的开关。系统缺省设置是“关闭”，在用户需要这些功能时请“开启”。 1.首先，登录邮箱，进入设置-帐户； 然后，在“帐户”设置中，找到设置项，进行设置，如下： 最后，保存设置，即打开了相应的服务。 ","link":"https://liujinyang6.github.io/post/chang-yong-de-you-xiang-fu-wu-qi/"},{"title":"Requests教程","content":"发送get请求 get请求 导入requests后，用get方法就能直接访问url地址，如：https://www.baidu.com 这里的r也就是response，请求后的返回值，可以调用response里的status_code方法查看状态码 状态码200只能说明这个接口访问的服务器地址是对的，并不能说明功能OK，一般要查看响应的内容，r.text（r.content()）是返回文本信息 示例： # 导入requests库 import requests # 请求url urlstr = 'https://www.baidu.com' # 发送请求 r = requests.get(url = urlstr) # 查看响应内容 print(r.text) 携带参数发送get请求 再发一个带参数的get请求，如玩安卓搜索，地址为：https://www.wanandroid.com/article/query?k=Android 请求参数：k=Android，可以以字典的形式传参:{&quot;k&quot;: &quot; Android &quot;} 多个参数格式：{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot;} 示例： # 导入requests库 import requests # 请求url urlstr = 'https://www.wanandroid.com/article/query' # 请求参数 payload = {'k':'测试'} # 发送请求 r = requests.get(url = urlstr, params = payload) # 查看响应结果 print(r.text) print(r.status_code) response response的返回内容还有其他更多信息： r.status_code #响应状态码 r.content #字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩 r.headers #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None r.json() #Requests中内置的JSON解码器，处理后对应Python的dict r.url # 获取url r.encoding # 编码格式 r.cookies # 获取response返回的cookie r.raw #返回原始响应体 r.text #字符串方式的响应体，会自动根据响应头部的字符编码进行解码 r.raise_for_status() #失败请求(非200响应)抛出异常 发送post请求（json） 发送post的请求参考例子很简单，实际遇到的情况却是很复杂的，首先第一个post请求肯定是登录了，但登录是最难处理的。登录问题解决了，后面都简单了。 post请求(json形式) post的body是json类型，有两种方法来传递json数据： 第一种：先导入json模块，用dumps方法转化成json格式。 第二种：使用json参数默认处理成json格式进行传递。 将返回结果，传到data里。 示例1： # 导入requests、json库 import requests import json # 发送post请求 urlstr = 'http://httpbin.org/post' # 请求参数 payload = {'key1':'value1','key2':'value2'} # 通过json.dumps方法将Python字符串转换成json类型 payload = json.dumps(payload) # 发送请求 r = requests.post(url = urlstr, data = payload) # 获取结果 print(r.text) # 如果返回值为json格式可以通过r.json方法来查看结果 print(r.json()) 示例2： # 导入requests、json库 import requests import json # 发送post请求 urlstr = 'http://httpbin.org/post' # 请求参数 payload = {'key1':'value1','key2':'value2'} # 发送请求，接口请求为json数据，通过json=自动将Python数据类型转换为json数据类型 r = requests.post(url = urlstr, json = payload) # 获取结果 print(r.text) # 如果返回值为json格式可以通过r.json方法来查看结果 print(r.json()) headers 以玩Android登录为例，抓包查看请求头，header为Python的字典类型，所以可以支持dict类型的所有操作方式添加header信息，可以直接定义{}，也可以通过dict[key]的方式添加。 示例： # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求头 header = {'User-Agent':'Molilla/6.0'} # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload, headers = header) # 获取结果 print(r.text) print(r.headers) 发送post请求（data） 前面示例的是传json参数，有些post请求不是传json类型数据的，下面就以传data参数为例。 post请求(表单形式) 用上面给的示例，做个简单修改，发个post请求，payload参数是字典类型，传到form里（注意post请求参数使用data=），示例中的response返回的是一个json，所以可以通过r.json的方式来查看结果，通过dict引用的方式取值dict[‘key’] 示例： # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload) # 获取结果 print(r.text) # 查看类型 print(type(r.json())) # 查看后类型为字典类型，r.json()将response中返回的json处理成了dict # 通过dict的key来访问对应的值 print(r.json()['data']['username']) 有时候body参数并不是json格式，是key=value格式，也就是前面介绍post请求四种数据类型里面的第二种。 如何判断登录成功？ step 1 ：判断登录成功，可以抓取页面上的关键元素，比如：账号名称，注销按钮 step2 ：通过正则表达式提出这2个关键字 示例： # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload) # 获取结果 print(r.text) # 查看类型 print(type(r.json())) # 查看后类型为字典类型，r.json()将response中返回的json处理成了dict # 通过dict的key来访问对应的值 print(r.json()['data']['username']) if r.json()['data']['username'] == payload['username']: print(&quot;登录成功！&quot;) 发https请求（ssl） 本来最新的requests库V1.13.0是支持https请求的，但是一般写脚本时候，我们会用抓包工具fiddler，这时候会 报：requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590) 解决方法： 不启用fiddler，直接发https请求，不会有SSL问题（也就是说不想看到SSL问题，关掉fiddler就行） 启动fiddler抓包，错误提示就是上面这样的。首先我找了很多的资料，有很多人说关闭证书验证（verify=False））可以解决这个问题或者说是在进行GET时,指定SSL证书。 response = requests.get('http://www.baidu.com/', headers = header, verify=False) 但我用以上两种方法都没有完美解决此问题，而且有些还有后续错误比如InsecureRequestWarning 只要安装一下几个requests依赖包就可以解决此问题 pip install cryptography pip install pyOpenSSL pip install certifi session关联接口 前面模拟登录了玩安卓，但这只是第一步，一般登录后，还会有其它的操作，如发帖，评论等，这时候如何保持会话呢？ 使用session登录 使用session登录 s = requests.session() 通过session函数自动携带上次请求返回的cookie信息，发送二次post请求 示例： # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 初始化session对象 s = requests.session() # 通过session对象发送post请求，服务器设置在本地的cookie会保存在本地 r = s.post(url = urlstr, data = payload) # 通过session对象继续发送请求，自动携带上一个请求返回的cookie r2 = s.get('https://www.wanandroid.com/lg/todo/list/0') # 获取结果 print(r.text) print(r2.text) json数据处理 有些post的请求参数是json格式的，这个前面post请求里面提到过，需要导入json模块处理。 一般常见的接口返回数据也是json格式的，我们在做处理时候，往往只需要提取其中几个关键的参数就行，这时候就需要json来解析返回的数据了。 前提：import json json.dumps 将 Python 对象编码成 JSON 字符串--------相当于------encode编码 json.loads 将已编码的 JSON 字符串解码为 Python 对象--------相当于------decode解码 Json简介：Json，全名 JavaScript Object Notation，是一种轻量级的数据交换格式,常用于http请求中。 Encode（python-&gt;json） 首先说下为什么要encode，python里面bool值是True和False,json里面bool值是true和false,并且区分大小写，这就尴尬了，明明都是bool值。 在python里面写的代码，传到json里，肯定识别不了，所以需要把python的代码经过encode后成为json可识别的数据类型。 举个简单例子，下图中dict类型经过json.dumps()后变成str，True变成了true,False变成了fasle. 以下对应关系表是从json模块的源码里面爬出来的.python的数据类，经过encode成json的数据类型，对应的表如下： Decode（json-&gt;python） 以登录成功返回结果：{&quot;success&quot;:true}为例，我们其实最想知道的是success这个字段返回的是True还是False 如果以content字节输出，返回的是一个字符串：{&quot;success&quot;:true}，这样获取后面那个结果就不方便了 如果经过json解码后，返回的就是一个字典：{u'success': True}，这样获取后面那个结果，就用字典的方式去取值：result2[&quot;success&quot;] 同样json数据转化成python可识别的数据，对应的表关系如下 案例分析 比如打开快递网：http://www.kuaidi.com/，搜索某个单号，判断它的状态是不是已签收 实现代码如下： token登录 有些登录不是用cookie来验证的，是用token参数来判断是否登录。 token传参有两种一种是放在请求头里，本质上是跟cookie是一样的，只是换个单词而已；另外一种是在url请求参数里，这种更直观。 如下图的这个登录，无cookies 但是登录成功后有返回token 登录成功后继续操作其它页面，发现post请求的请求头，都会带token参数 这种请求其实比cookie更简单，直接把登录后的token放到头部就行 token关联 步骤： 用脚本实现登录，获取token参数，获取后传参到请求头就可以了 如果登录有验证码，前面的脚本登录步骤就省略了，自己手动登录后获取token import requests body = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;} # 这里账号密码是抓包后的数据 s = requests.session() login_url = &quot;http://xxxx/login&quot; # 自己找带token的网址 login_request = s.post(login_url, data = body) # 这里token在返回的json里，可以直接提取 token = login_request.json()[&quot;token&quot;] # 添加token到请求头部 header[&quot;token&quot;] = token # 如果这个post请求头的其他参数变了，也可以直接更新 header[&quot;Content-Length&quot;] = &quot;9&quot; body1 = {&quot;key&quot;: &quot;value&quot;} # 调用登录后的其他接口 post_request = s.post(post_url, headers = header, data = body1) # 查看结果 print(post_request.content) 携带cookie发送请求 这里整理了4种携带cookie的方法： 方法一： 通过r.cookies手动获取上一请求返回的cookie来设置下次请求的cookie 示例： &quot;&quot;&quot; 通过r.cookies手动获取上一请求返回的cookie来设置下次请求的cookie &quot;&quot;&quot; # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload) # 获取结果 print(r.text) # 获取返回的cookie print(r.cookies) # 获取返回的header print(r.headers) # 获取上次请求返回的response中的cookie，传递给下次请求 cookie = r.cookies # 携带cookie发送请求 r2 = requests.get('http://www.wanandroid.com/lg/todo/list/0', cookies = cookie ) # 查看第二个请求的结果 print(r2.text) print(r2.status_code) 方法二： 通过rquests.session自动设置cookie，来完成访问 &quot;&quot;&quot; 通过rquests.session自动设置cookie，来完成访问 &quot;&quot;&quot; # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 初始化session对象 s = requests.session() # 通过session对象发送post请求，服务器设置在本地的cookie会保存在本地 r = s.post(url = urlstr, data = payload) # 通过session对象继续发送请求，自动携带上一个请求返回的cookie r2 = s.get('https://www.wanandroid.com/lg/todo/list/0') # 获取结果 print(r.text) print(r2.text) 方法三： 通过定制cookie，单独设置cookie来访问目标网址 &quot;&quot;&quot; 通过定制cookie，单独设置cookie来访问目标网址 &quot;&quot;&quot; # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload) print(r.text) print(r.cookies['JSESSIONID']) # 获取上次请求返回的response中的cookie，通过字典的形式引用cookie返回的JSESSIONID， # 放入下一次请求的cookie中 cookie = { 'JSESSIONID':r.cookie['JSESSIONID'] } # 携带cookie发送请求 r2 = requests.get('https://www.wanandroid.com/lg/todo/list/0',cookies = cookie) # 查看结果 print(r2.text) print(r2.headers) 方法四： 通过定制cookie，放入header来访问目标网址 &quot;&quot;&quot; 通过定制cookie，放入header来访问目标网址 &quot;&quot;&quot; # 导入requests import requests # 请求url urlstr = 'https://www.wanandroid.com/user/login' # 请求参数 payload = {'username':'liu','password':'123456'} # 发送post请求 r = requests.post(url = urlstr, data = payload) print(r.text) print(r.cookies) print(r.headers) print(r.cookies['JSESSIONID']) # 获取上次请求返回的response中的cookie，通过字典的形式引用cookie返回的JSESSIONID，放入 # 下一次请求的header中 header = { 'cookie':'JSESSIONID='+r.cookies['JSESSIONID'] } # 携带header发送请求 r2 = requests.get('https://www.wanandroid.com/lg/todo/list/0',headers = header) print(r2.text) print(r2.headers) # str.find方法返回-1表示没有找到，非-1表示找到 result = r2.text.find(&quot;已完成清单&quot;) print(result) if result != -1: print(&quot;查询成功！&quot;) else: print(&quot;查询失败！&quot;) ","link":"https://liujinyang6.github.io/post/requests-jiao-cheng/"},{"title":"Loadrunner脚本编写练习","content":"参数关联、检查点设置 Action() { int i; // 获取动态sessionid web_reg_save_param(&quot;sessionid&quot;, &quot;LB=&lt;input type=hidden name=userSession value=&quot;, &quot;RB=&gt;&quot;, &quot;Ord=1&quot;, &quot;Search=All&quot;, LAST); web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:1080/WebTours/&quot;,LAST); // 设置登录检查点 web_reg_find(&quot;Search=All&quot;, &quot;SaveCount=checkcount&quot;, &quot;Text=liang01&quot;, LAST); lr_start_transaction(&quot;login&quot;); web_submit_data(&quot;web_submit_data&quot;, &quot;Action=http://127.0.0.1:1080/WebTours/login.pl&quot;, &quot;Method=POST&quot;, &quot;TargetFrame=&quot;, &quot;Referer=&quot;, ITEMDATA, &quot;Name=userSession&quot;, &quot;Value={sessionid}&quot;, ENDITEM, &quot;Name=username&quot;, &quot;Value=liang01&quot;, ENDITEM, &quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM, LAST); // 将字符串转化为int i = atoi(lr_eval_string(&quot;{checkcount}&quot;)); if (i&gt;0) { lr_end_transaction(&quot;login&quot;,LR_PASS); } else{ lr_end_transaction(&quot;login&quot;,LR_FAIL); } return 0; } 参数使用 Action() { //将字符串&quot;test&quot;保存名为canshu的参数 //将值存为参数 lr_save_string(&quot;test&quot;,&quot;canshu&quot;); lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;)); lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;)); //提取canshu参数的值 //将值从参数中取出 lr_eval_string(&quot;{canshu}&quot;); } 高级关联 Action() { // 关联获取大类 web_reg_save_param(&quot;Did&quot;, &quot;LB=categoryId=&quot;, &quot;RB=\\&quot;&gt;&quot;, &quot;Ord=all&quot;, &quot;Search=All&quot;, LAST); // 访问首页 web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST); // 将一个字符串定义成一个参数 // 随机获取数组某一元素的值 lr_save_string(lr_paramarr_random(&quot;Did&quot;),&quot;did&quot;); // 根据索引获得数组某一元素的值 //lr_save_string(lr_paramarr_idx(&quot;Did&quot;,1),&quot;did&quot;); // 随机点击大类 web_url(&quot;catlog&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={did}&quot;,LAST); return 0; } 练习脚本： 按顺序点击访问页面 Action() { int i; web_reg_save_param(&quot;fidarr&quot;, &quot;LB=forumdisplay&amp;fid=&quot;, &quot;RB=\\&quot;&gt;&quot;, &quot;Ord=all&quot;, &quot;Search=All&quot;, LAST); web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST); for (i=1;i&lt;=5;i++) { lr_save_string(lr_paramarr_idx(&quot;fidarr&quot;,i*(int)2),&quot;fid&quot;); web_url(&quot;catalog&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php?mod=forumdisplay&amp;fid={fid}&quot;,LAST); } return 0; } 随机登录账号 Action() { int i = 0; web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST); lr_start_transaction(&quot;login&quot;); web_submit_data(&quot;login&quot;, &quot;Action=http://127.0.0.1:8888/discuz/upload/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&quot;, &quot;Method=POST&quot;, &quot;TargetFrame=&quot;, &quot;Referer=&quot;, ITEMDATA, &quot;Name=fastloginfield&quot;, &quot;Value=username&quot;, ENDITEM, &quot;Name=username&quot;, &quot;Value={username}&quot;, ENDITEM, &quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM, &quot;Name=quickforward&quot;, &quot;Value=yes&quot;, ENDITEM, &quot;Name=handlekey&quot;, &quot;Value=ls&quot;, ENDITEM, LAST); web_reg_find(&quot;Search=All&quot;, &quot;SaveCount=namecount&quot;, &quot;Text={username}&quot;, LAST); web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST); i = atoi(lr_eval_string(&quot;{namecount}&quot;)); if (i&gt;0) { lr_end_transaction(&quot;login&quot;,LR_PASS); lr_output_message(&quot;namecount的值为%d,出现次数大于0，事务通过&quot;,i); } else{ lr_end_transaction(&quot;login&quot;,LR_FAIL); lr_output_message(&quot;namecount的值为%d，出现次数为0，事务失败&quot;,i); } return 0; } 随机点击任意一个大类，再顺序点击其下的小类 Action() { int i; web_reg_save_param(&quot;catalog_Big&quot;, &quot;LB=hidCategoryId\\&quot; value=\\&quot;&quot;, &quot;RB=\\&quot; /&gt;&lt;/td&gt;&quot;, &quot;Ord=all&quot;, &quot;Search=All&quot;, LAST); web_url(&quot;petshop&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST); lr_save_string(lr_paramarr_random(&quot;catalog_Big&quot;),&quot;catalog&quot;); web_reg_save_param(&quot;catalog_Small&quot;, &quot;LB=&lt;a href='Items.aspx?productId=&quot;, &quot;RB=&amp;categoryId=&quot;, &quot;Ord=all&quot;, &quot;Search=All&quot;, LAST); web_url(&quot;random_catalog_big&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={catalog}&quot;,LAST); for (i=1;i&lt;=4;i++) { //获取小类的catalogId对应的值 lr_save_string(lr_paramarr_idx(&quot;catalog_Small&quot;,i*(int)2),&quot;catalog_small&quot;); web_submit_data(&quot;web_submit_data&quot;, &quot;Action=http://127.0.0.1/pet/Items.aspx&quot;, &quot;Method=GET&quot;, &quot;TargetFrame=&quot;, &quot;Referer=&quot;, ITEMDATA, &quot;Name=productId&quot;, &quot;Value={catalog_small}&quot;, ENDITEM, &quot;Name=categoryId&quot;, &quot;Value={catalog}&quot;, ENDITEM, LAST); } return 0; } ","link":"https://liujinyang6.github.io/post/loadrunner-jiao-ben-bian-xie-lian-xi/"},{"title":"Loadrunner脚本常用函数","content":"web_url() 作用：模拟浏览器发出访问目标网址的请求=get 请求 语法：Web_url(“步骤名称”,“url=http：//xxxxx”,LAST); eg: web_url(“访问 baidu”，“url=http://www.baidu.com”，LAST); Web_submit_data() 作用：向服务器提交表单数据,支持 post 和 get 方法 web_custom_request() 作用：自定义向服务器发送 http请求，支持的任意方法的请 求，可以代替web_url 和 web_submit_data 函数 web_reg_save_param() 作用：通过目标对象的左右边界获取服务器返回的动态数据 方法：工具栏→insert→new step 输入 web_reg_save_param，点击确定 步骤： 1、 确定需要关联的对象（动态的、变化的，服务器发送给客户端的） 2、 使用 httpwatch/fiddler 抓取目标对象，来确定该数据是由哪个请求产生的 3、 获取目标对象的左右边界，及请求的位置 4、 填写关联函数的参数名称，左右边界、查找数、查找位置 5、 用该参数名替换需要向服务器提交的动态数据，引用参数：{参数名} 注意：从名称上知道关联函数是注册型函数，所以应该放在产生动态数据请求的前面，save_param 表示关联函数获取下来之后保存为一个参数，所以脚本中引用时应该加{} 。 数组操作 //返回参数数组指定位置的参数的值 lr_paramarr_idx(&quot;Did&quot;,1); //返回参数数组的元素（参数）的个数 lr_paramarr_len(&quot;Did&quot;); //返回参数数组随机位置的参数的值 lr_paramarr_random(&quot;Did&quot;); lr_think_time（） 作用：等待n秒 用法：lr_think_time（n） 事务函数 开始事务：lr_start_transaction(&quot;open&quot;); 结束事务：lr_end_transaction(&quot;open&quot;, LR_AUTO); 事务时间=响应时间+思考时间+浪费时间+函数自身执行时间，指的是客户端发出请 求到得到响应的整个过程所经历的时间。 事务的四种状态：LR_AUTO,LR_STOP,LR_PASS,LR_FAIL LR_AUTO: 系统自动判断依赖 http 返回的状态码,状态码为200事务就通过 检查点函数 文本检查点函数，优先使用 Web_reg_find() 注意：从名称上知道关联函数是注册型函数，所以应该放在检查数据请求的前面 lr_eval_string() 作用：取出参数的值 语法：lr_eval_string(“{参数名}”) lr_save_string() 作用：保存字符串到一个参数 语法：lr_save_string(“value”，参数名); lr_output_message() 作用：在控制台打印信息 类型转化 atoi()：将字符串类型转为整型 itoa()：将整型转为字符串类型 lr_rendezvous() 作用：设置集合点 用法：lr_rendezvous(&quot;集合点名称&quot;); ","link":"https://liujinyang6.github.io/post/loadrunner-jiao-ben-chang-yong-han-shu/"},{"title":"软件测试流程","content":"Posted on 2018-12-12 | In Hexo 需求分析： - 整体流程图： 需求提取 -&gt; 需求分析 -&gt; 需求评审 -&gt; 更新后的测试需求跟踪xmind - 分析流程： 需求提取： 分析依据（包括：需求矩阵、产品交互图、需求说明书） 获取需求的纬度 客户价值 可以为客户带来哪些价值？ 可以解决哪些问题？ 根据以上问题定位功能是否合理 UI功能 - 展示功能 模块关联-历史模块 新功能模块关联 考虑是否关联？耦合部分是否需要支持？ 客户使用场景-部署方式 网络特性 客户使用服务器常见外设 性能参数-性能要求 网卡最低速率 硬件支持 输出（提取最原始的测试需求） 需求分析： 分析依据（五维分析） 用户场景 功能是否和场景强关联 网络拓扑能否满足客户需求 和竞争对手比较差异 功能是否能满足客户实际应用场景 是否考虑了用户的实际操作 明确性 范围明确性（参数、类型长度范围） 清晰性限制等范畴 无法预知影响的需求提出进行确定，风险 二义性 概念模糊【大概念、第三方支持、与上个版本相同】 支持与不支持等范畴 一个需求描述能出现多种理解 完整性 需求一致性【用户需求、需求规格、需求矩阵三者是否同意】 需求完整【隐形需求】 关联性【与新老功能、与外置软件设备】 可测试性 实现测试需要的工具、方法【调试、接口命令】 定位方式【日志等形式观察】 复杂环境、容量边界、操作时过程不可见 输出 测试需求跟踪 缺陷预防bug 工具需求 整理出明确的需求点 测试地图 分析思路误区：需求和实现的区别【现有需求才有代码实现，不能把代码实现当作需求】 需求分析的意义 明确产品给客户带来的价值 明确产品支持和不支持的功能 明确产品各个功能的约束性 知道开发实现功能 知道测试分析和产出测试点 测试设计： - 测试分析： 我们需要做什么？ 把明确的需求点转换成测试项 缺陷预防 怎么做？ 整体模块分析 逻辑分析【这一点主要是从产品实现的原理上去分析可能的影响】 怎么做？ 开发的设计文档 补充和挖掘测试点 全部服务的异常监控、服务重启 各类存储对空间的占用、占满、是否需要做存储的接口测试 所有类型的管理员、操作权限测试、支持的多少管理员并发操作 对流程图的挖掘 – 流程图全部流程测试、流程图重要的节点异常测试 对状态的挖掘 – 所有状态的相互转化需要覆盖全、状态转化是否合理、每一个状态下哪些操作可做哪些不可做，多个状态是否可以共存 对关联项的挖掘 – 流程进展到哪一步关机重启/服务重启、和备份配置的关联，和操作日志的关联等等 任务的并发操作测试、是否可配置、是否会出现性能不足，是否符合用户场景 异常处理机制测试，异常处理机制是否完善 指标测试，开发的指标设计是否合理 修正不合理的需求 如何分析 逻辑原理： 该模块是否涉及到一些全新的概念(比如我们的 bbc 全量包)，需要明确? 该模块包括哪些服务? 该模块涉及到哪些存储技术(如 mysql、dap、redis)?具体怎么存储的?占用大小如何? 该模块的操作流程有哪些?是否有子流程图? 该模块是否有多个状态的转化?是否有明确的状态转化图? 该模块对多个管理员是否区分，管理员权限如何设计? 该模块是否有一些特殊的操作限制?操作限制是否有明确的表格? 该模块的任务是否有并发需求?并发的设计? 该模块的所有指标如何? 该模块是否有异常处理机制?在设备各种异常时，该模块的设计是否满足能稳健运行? 场景分析 从用户的使用习惯和使用方法去分析影响 检查当前案例是否覆盖到用户场景 关联测试分析： 考虑你的模块所在整个系统的地位，分析上下游的影响 对老功能的影响 经验补充分析 版本分析 模块分析 输出 测试项 补充测试地图 - 测试设计： 需要做什么？ 把测试项细化成测试点 缺陷预防 需要做什么？ 基本设计方法 等价类划分法【将输入域和输出域划分为不同的等价类，等价类之内的操作结果相同】，使用范围：显示输入框输入 边界值法【需要结合等价类划分法方法，在划分出来的等价类选取有代表性的值】 正反对比【一般会放到同一个用例里覆盖】 字符多样性【考虑不同字符的输入】 测试类型 产品专项测试 正交组合设计【正交矩阵，覆盖各个参数间的组合情况】 业务逻辑设计【根据业务设计测试点】 输出： 基本测试点 - 用例设计： 需要做什么？ 把测试点用文字完整表述出来 怎么做？ 功能用例框架： 模块框架模板 需求类 UI测试【如果UI用例可以被功能用例覆盖，这里可以不写】 公共测试类： 链接 选中会有高亮显示 点击跳转到对应页面 当前页面对应的名称下有区别显示 翻页 按钮 输入框【这个功能用例一般可以覆盖】 下拉框 排序 条目选择【这个很重要，第一次集成测试一定要保证每个选项都是有效的】 搜索 所有字符类型验证 为空验证 模糊搜索 精确搜索 搜索不存在的关键词 刷新 验证自动刷新 验证手动刷新 验证持续刷新 拖动 移动 点击下移，往下移动一行 点击上移，往上移动一行 最上面的行，上移不能点击，图标灰色 最下面的行，下移不能点击，图标灰色 功能测试 测试点： 功能基本流程逻辑覆盖 业务流程多样性覆盖 用户操作习惯的多样性 模块配置的多样性 数据流的多样性覆盖 测试目录 平级分类相对独立 上下级分类有关联 下级从上级细化而来 关联类： 模块与模块之间的 模块与功能之间 模块与硬件之间 场景类 建模思路 部署方式【比如用户一般使用2主机还是3主机部署集群】 数据流 业务流【用户是怎么使用申请工单，是怎么样的完整流程】 操作顺序【创建云主机的顺序之类的】 配置方法【用户一般怎么配置使用静态路由】 使用时间【用户会不会连续长时间开启云主机】 用户角色【一般那些角色做什么操作】 用户操作的设计方向 最常用的功能 最容易出现网上问题的功能 典型客户使用的功能 版本的性能验证 专项类 兼容性 可靠性【测试产品在异常情况下能否正常工作或者是恢复正常工作，可靠性重点测试对模块自身处理的覆盖】. 补充：容错性测试【测试系统在非正常操作、非正常的外部环境下是否能够处理错误和正常运行】 eg： 针对数据库的测试：【磁盘空间不足、数据库文件损坏、无读写数据权限、写数据时断电、写数据时强制关闭mysql、读写速度】 针对网络设备：【网络中有攻击数据、丢包时延大、IP冲突、网络线路断开、同时掉电】 针对程序：【 客户端进程被手动停止、设备后台资源cpu、内存占满】 安全性【主要是验证程序有哪些缺陷可能会造成安全方面的问题】 eg： 密码加密方式【什么时候用明文，什么时候用密码显示】 隐私数据隐藏【用户的隐私显示】 设备的完整目录【完整的目录会增加后台被攻击的危险】 文件上传功能【检查上传的文件类型；限制上传文件的权限】 防暴力破解【对于连线认证之类的操作要冻结、禁用其连续错误尝试操作】 脚本测试 使用注意细节 文件夹以01-xx，02-xx区分开 每个文件夹下不能超过10个用例 每个测试用例一个测试点 在02-功能测试的描述中，备注说明功能测试框架的思路 - 用例整体规范： 用例标题【好的标题需要准确的表达你的测试目的、要测试的测试点】 eg： 测试。。。 验证。。。 。。。的测试 与。。。的关联测试 。。。的异常测试 。。。的兼容性测试 用例属性 测试环境【默认的前置条件可以不用写；写的前置条件要准确，不要写的模糊】 测试方法 优先级 BVT【最最最基本的功能】-BVT(10%)：模块最基本的功能验证(含常用部署、基本关联)，推荐1级用例的20%左右 level1【基本操作、基本场景】-Leve1(30%)：基本需求点，基本逻辑，基本可靠性，基本关联，基本用户场景 level2【比较少见的正常操作】-Leve2(40%)：常见功能/逻辑细化点/专项细化点，常见关联/容错/边界值/用户场景 level3【异常操作；后续不需要再执行】-Leve3(20%)：错误提示、极少测试的用例、非常见部署方式/用户场景/容错/边界值等 用例格式 前置条件 测试步骤【单个用例全部步骤不能超过8步】 后置条件【不是必填的】 预期结果 备注【不是必填的】 语言规范 语言简练 不能出现模糊的形容词【比如说大概、可能、很多、差不多】 可维护性 灵活运用模块备注 设计原则 目的明确【一个用例对应一个测试点；测试步骤和测试目的一致】 用例效率 保证设计出来的用例10分钟内可以执行完成； 用例需要的环境可以整理出来，然后写到模块备注中，让执行者先准备好环境一次性执行全部用例； 执行的时候按照测试集方式来执行； 有工具可以实现的用例不要采用脚本方式实现 测试步骤： 用户角度 设计的用例要符合用户的操作顺序和操作习惯 符合用户的使用环境 符合用户的配置 可执行 不要出现那种用例设计没有错，但是执行起来很复杂或者是依赖环境很夸张的用例 正反对比 这一点很重要，很多时候我们会把有正反操作的用例分开写，其实是可以合在一个用例里面写 强弱关联 对于强关联的步骤一定要写清楚 对于弱关联的可以备注或者是不写 测试用例不能出现操作步骤 直接写需要做的操作就可以了 预期结果： 用户角度： 反思用户期望操作完会有什么结果 反思客户最关注的测试点 可检查 预期结果要可以观察到，不要写的很模糊 把重点检查的检查点覆盖到 用例编写口诀 强弱正反之业务 重点突出之效率 目的明确之语言 框架覆盖之检查 逻辑场景之经验 ","link":"https://liujinyang6.github.io/post/ruan-jian-ce-shi-liu-cheng/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://liujinyang6.github.io/post/hello-gridea/"},{"title":"Hadoop+Zookeeper+Spark+Hbase大数据平台搭建","content":"Posted on 2018-06-10 | In Hexo 前言 随着这学期对于hbase和spark的学习，加上上学期学习的hadoop知识，这次专周在这一年学习的基础上，使用虚拟机或者实机&gt;搭建一个伪分布式大数据平台，涉及hadoop平台、hbase平台还有spark平台，使用一台虚拟机充当主节点master，两台虚拟机&gt;充当子节点slave、slave1。 前期准备 hadoop-2.7.6.tar.gz hbase-1.2.6-bin.tar.gz jdk-8u161-linux-x64.tar.gz zookeeper-3.4.10.tar.gz sqoop-1.99.7.tar.gz spark-2.2.1-bin-hadoop2.7.tgz kafka_2.11-1.1.0.tgz 修改hostname 在root用户下的主界面运行一下命令： $ vim /etc/hostname 将localhost修改为姓名缩写和学号后四位然后:wq保存退出。 在每个节点/etc/hosts中加入本机ip和其他节点ip 在root用户下的主界面运行一下命令： $ vim /etc/hosts 添加以下内容： 127.0.0.1 localhost 10.19.2.197 ljy0326 10.19.2.209 pxc0305 10.19.1.242 huwei0303 必须保证hosts内每个ip对应的主机名与hostname一致 配置免密登录 代码如下： $ sudo apt-get install ssh $ ssh-keygen -t rsa $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys $ sudo gedit authorized_keys $ ssh huwei0303 添加完成，效果如图： 下载资源 下载JDK 请登录如下网站，下载你想要的版本http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html 下载Hadoop等其他安装包 https://mirrors.tuna.tsinghua.edu.cn/apache/ 需要下载 Hadoop、HBase、Spark、Scala、Sqoop、kafka、Zookeeper 解压文件 解压命令： tar -zxvf ****.gz -C /opt/文件夹名 将jdk1.8.0_144文件夹更名为java 将hadoop-2.6.7 文件夹更名为hadoop 其余文件夹同上。 在每个节点配置环境变量 执行以下命令： $ vim /etc/profile 在文件最后输入以下内容： export JAVA_HOME=/opt/java export HADOOP_HOME=/opt/hadoop export ZOOKEEPER_HOME=/opt/zookeeper export HBASE_HOME=/opt/hbase export SPARK_HOME=/opt/spark export SCALA_HOME=/opt/scala export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf:$HBASE_HOME/bin:$SPARK_HOME/bin:$SCALA_HOME/bin:$SQOOP_HOME/bin 配置如图： 保存退出后需使环境变量生效，执行以下命令： $ source /etc/profile 然后生效后运行java -version查看jdk配置是否成功 在每个节点创建文件夹并改权限 该文件夹为Hadoop相关文件夹 创建命令： $ mkdir -p /opt/hadoop 将主节点设置为NTP服务器 一个Hadoop集群就是一个小型局域网，我们需要设定一台NTP服务器作为整个网络的标准时间参考，使用网络（集群）内的所有机器保持时间一致！以下是详细的操作步骤： 安装ntp软件 执行命令： $ apt-get install ntp 修改配置文件 打开文件需要修改的配置文件,执行以下命令： $ vim /etc/ntp.conf # Specify one or more NTP servers server 127.127.1.0 因为是内网，所以用本地时间做为服务器时间，注意这里不是127.0.0.1 在配置文件里找到以下4条并注释掉: #server 0.ubuntu.pool.ntp.org #server 1.ubuntu.pool.ntp.org #server 2.ubuntu.pool.ntp.org #server 3.ubuntu.pool.ntp.org 增加了NTP服务器自身到时间服务器的同步 fudge 127.127.1.0 stratum 8 增加了一些需要同步的客户端的ip restrict -4 default kod notrap nomodify nopeer noquery limited restrict -6 default kod notrap nomodify nopeer noquery limited restrict 10.19.2.209 restrict 10.19.1.242 配置完成如图： 配置Hadoop 配置 hadoop-env.sh # The java implementation to use. 修改为自己的JAVA_HOME路径 export JAVA_HOME=/opt/java/jdk-8u171-linux-x64 配置hdfs-site.xml 配置如图： 配置core-site.xml 配置如图： 配置mapred-site.xml 配置如图： 配置slaves 添加节点的主机名： ljy0326 pxc0305 huwei0303 添加完毕后保存退出。 配置 yarn-site.xml 如图： 配置JournalNode JournalNode的配置是在hdfs-site.xml文件中， 打开文件： $ vim hdfs-site.xml 在原有的配置下面添加一下内容，需保证所有的内容均在 &lt;!--指定hdfs的nameservice为ljy0326，需要和core-site.xml中的保持一致--&gt; &lt;property&gt; &lt;name&gt;dfs.nameservices&lt;/name&gt; &lt;value&gt;ljy0326&lt;/value&gt; &lt;/property&gt; &lt;!-- ns下面有两个NameNode，分别是nn1，nn2--&gt; &lt;property&gt; &lt;name&gt;dfs.ha.namenodes.ljy0326&lt;/name&gt; &lt;value&gt;nn1,nn2&lt;/value&gt; &lt;/property&gt; &lt;!--配置 nn1的RPC通信地址--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.rpc-address.ljy0326.nn1&lt;/name&gt; &lt;value&gt;ljy0326:9000&lt;/value&gt; &lt;/property&gt; &lt;!--配置nn1的http通信地址--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address.ljy0326.nn1&lt;/name&gt; &lt;value&gt;ljy0326:50070&lt;/value&gt; &lt;/property&gt; &lt;!--配置 nn2的RPC通信地址--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.rpc-address.ljy0326.nn2&lt;/name&gt; &lt;value&gt;pxc0305:9000&lt;/value&gt; &lt;/property&gt; &lt;!--配置nn2的http通信地址--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address.ljy0326.nn2&lt;/name&gt; &lt;value&gt;pxc0305:50070&lt;/value&gt; &lt;/property&gt; &lt;!--指定NameNode的元数据在JournalNode上的存放位置--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt; &lt;value&gt;qjournal://ljy0326:8485;pxc0305:8485;huwei0303:8485/ljy0326&lt;/value&gt; &lt;/property&gt; &lt;!--指定JournalNode在本地磁盘存放数据的位置--&gt; &lt;property&gt; &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/journal&lt;/value&gt; &lt;/property&gt; &lt;!--开启NameNode故障时自动切换--&gt; &lt;property&gt; &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!--配置失败自动切换实现方式--&gt; &lt;property&gt; &lt;name&gt;dfs.client.failover.proxy.provider.ljy0326&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyPrivider&lt;/value&gt; &lt;/property&gt; &lt;!--配置隔离机制，如果ssh是默认22端口，value直接写sshfence即可--&gt; &lt;property&gt; &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt; &lt;value&gt;sshfence(ljy0326:22)&lt;/value&gt; &lt;/property&gt; &lt;!--使用隔离机制时需要ssh免登陆--&gt; &lt;property&gt; &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt; &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt; &lt;/property&gt; 将配置好的文件发送到其他节点: 运行shell命令: $ scp –r /opt/java/jdk root@huwei0303:/opt/java $ scp –r /opt/java/jdk root@pxc0305:/opt $ scp –r /opt/hadoop/hadoop-2.6.7 root@huwei0303:/opt/hadoop $ scp –r /opt/hadoop/hadoop-2.6.7 root@pxc0305:/opt/hadoop 格式化namenode 在master节点运行shell命令: $ hadoop namenode –format 提示0，则格式化正常 启动hadoop集群 运行命令： $ /sbin/start-all.sh 输入命令jps，hadoop启动成功如图： 配置ZooKeeper 创建相关文件 $ sudo mkdir -p /usr/local/zkData //该文件夹为Zookeeper数据文件夹 $ mkdir -p /opt/zookeeper/logs //该文件夹存放Zookeeper 日志文件 在ljy0326节点运行shell命令: $ echo 1 &gt;&gt; /usr/local/zkData/myid 在pxc0305 节点运行shell命令 $ echo 2 &gt;&gt; /usr/local/zkData/myid 在huwei0303 节点运行shell命令 $ echo 3 &gt;&gt; /usr/local/zkData/myid 配置/opt/zookeeper/conf/zoo.cfg # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. # 将此处改为原先创建好的目录 dataDir=/usr/local/zkData # the port at which the clients will connect clientPort=2181 server.1=0.0.0.0:2888:3888 server.2=pxc0305:2888:3888 server.3=huwei0303:2888:3888 配置完成如图： 注意此处（3个虚拟机要分别配置） 在pxc0305节点，将此处配置为 server.1=ljy0326:2888:3888 server.2=0.0.0.0:2888:3888 server.3=huwei0303:2888:3888 在huwei0303节点，将此处配置为 server.1=ljy0326:2888:3888 server.2=pxc0305:2888:3888 server.3=0.0.0.0:2888:3888 配置/opt/zookeeper/bin/zkEnv.sh 找到 if [ &quot;x${ZOO_LOG_DIR}&quot; = &quot;x&quot; ] then ZOO_LOG_DIR=&quot;.&quot; fi 将.改为/opt/zookeeper/logs 将配置文件发送到其他节点 运行shell命令： $ scp –r /opt/zookeeper/ root@pxc0305:/opt $ scp –r /opt/zookeeper/ root@huwei0303:/opt 启动Zookeeper集群 在每个节点运行shell命令: $ zkServer.sh start 配置HBase 配置hbase-env.sh export JAVA_HOME=/opt/java/jdk //更改Java环境变量 配置hbase-site.xml &lt;configuration&gt; &lt;property&gt; //集群中所有RegionServer共享目录 &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://ljy0326:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; //集群的模式 &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; // zookeeper集群的URL配置 &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;ljy0326,pxc0305,huwei0303&lt;/value&gt; &lt;/property&gt; &lt;property&gt; //指定ljy0326 &lt;name&gt;hbase.master&lt;/name&gt; &lt;value&gt;ljy0326&lt;/value&gt; &lt;/property&gt; &lt;property&gt; //客户端与zookeeper的连接端口 &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt; &lt;value&gt;2181&lt;/value&gt; &lt;/property&gt; &lt;property&gt; //客户端与zookeeper的通讯超时时间 &lt;name&gt;zookeeper.session.timeout.ms&lt;/name&gt; &lt;value&gt;1800000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; // RegionServer处理IO请求的线程数 &lt;name&gt;hbase.regionserver.handler.count&lt;/name&gt; &lt;value&gt;100&lt;/value&gt; &lt;/property&gt; &lt;property&gt; //RegionServer发生Split的阔值 &lt;name&gt;hbase.hregion.max.filesize&lt;/name&gt; &lt;value&gt;2147483648&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置regionservers pxc0305 huwei0303 将配置文件发送到其他节点 $ scp –r /opt/hbase/ root@pxc0305:/opt $ scp –r /opt/hbase/ root@huwei0303:/opt 在master节点启动HBase $ start-hbase.sh 输入命令jps，Hbase启动成功如图： 搭建spark 在每个节点创建Spark相关目录: $ sudo mkdir –p /usr/local/spark //该目录用于存放worker信息和日志 配置spark-env.sh文件 配置如图： #在配置slave节点时，将SPARK_LOCAL_IP改为对应的IP地址或者Hostname 配置spark-defaults.conf 配置如图： 配置slaves #在文件中加入配置信息 pxc0305 huwei0303 将配置文件发送到其他节点 运行shell命令： $ scp –r /opt/spark/ root@pxc0305:/opt $ scp –r /opt/spark/ root@huwei0303:/opt $ scp –r /opt/scala/ root@pxc0305:/opt $ scp –r /opt/scala/ root@huwei0303:/opt 启动Spark集群 #在Hadoop集群启动的情况下运行以下命令: $ /opt/spark/spark-2.2.1/sbin/start-all.sh 搭建kafka 创建kafka相关目录 $ mkdir /opt/kafka/logs //存放kafka消息的目录，也可以使用默认的目录 修改配置文件 $ vim /opt/kafka/ kafka_2.11-1.1.0 /config/server.properties 需要修改的部分: broker.id=1 //当前机器在kafka机器里唯一标识，与zookeeper的myid相匹配 log.dirs=/opt/kafka/logs //存储消息的目录位置 将配置文件发送到其他节点 运行shell命令: scp –r /opt/spark/ root@pxc0305:/opt scp –r /opt/spark/ root@huwei0303:/opt 切换到pxc0305和huwei0303上修改配置文件: [root@pxc0305]# vim server.properties broker.id=2 [root@ huwei0303]# vim server.properties broker.id=3 启动kafka集群 保证先启动zookeeper集群 然后在每个节点的、kafka/sbin目录下运行 $ cd /opt/kafka/ kafka_2.11-1.1.0/sbin $ ./kafka-server-start.sh -daemon ../config/server.properties 若成功启动，输入jps可以看到 kafka 搭建sqoop1.99.7 配置第三方jar引用路径 $ vim /etc/profile $ export SQOOP_SERVER_EXTRA_LIB=$SQOOP_HOME/extra 最后把mysql的驱动jar文件复制到这个目录下。 配置sqoop.properties文件 org.apache.sqoop.submission.engine.mapreduce.configuration.directory=/opt/hadoop/etc/hadoop org.apache.sqoop.security.authentication.type=SIMPLE org.apache.sqoop.security.authentication.handler=org.apache.sqoop.security.authentication.SimpleAuthenticationHandler org.apache.sqoop.security.authentication.anonymous=true 验证配置是否有效 使用bin中的sqoop2-tool工具进行验证： $ bin/sqoop2-tool verify 这个工具也可用于软件升级。若没有什么问题，往下走。 启动sqoop $ bin/sqoop2-server start 安装mysql 在ljy0326上运行命令 $ apt-get install mysql-server-5.6 会提示设置root密码，设置完成则运行查看是否成功 检测搭建是否完成 搭建成功后每个节点jps运行截图： 结果如上图，大功告成！ ","link":"https://liujinyang6.github.io/post/hadoopzookeepersparkhbase-da-shu-ju-ping-tai-da-jian/"},{"title":"Github Pages+Hexo+腾讯云域名绑定","content":"Github Pages+Hexo+腾讯云域名绑定 Posted on 2018-05-14 | In Hexo Github Pages Github Pages可以免费托管，所以把博客托管到github上。 首先，创建一个github仓库，仓库的命名格式为：yourusername.github.io，然后根据提示进行下一步。 hexo搭建博客 本博客中使用了next的主题，所以会详细介绍下按照next主题搭建的步骤。 准备工作 1.首先要安装下node.js（官网下载）,如果已经安装可以跳过。 2.安装git（官网下载）。 3.安装Hexo： $ npm install -g hexo 安装成功后，使用version命令查看是否安装成功 $ hexo version 4.本地静态hexo博客 新建一个文件夹，作为你博客文件的根目录 命令行进入该文件夹下,输入以下命令，生成模板： $ hexo init 模板生成后，输入以下命令： $ npm install 最后可以运行hexo s命令查看是否搭建成功 下载主题 在 themes 文件夹内，新增一个next文件夹，并修改_config.yml 内的 theme 设定theme: next，即可切换到next主题。然后把next主题的内容clone到刚刚新建的next文件夹下: git clone https://github.com/liuJinYang6/hexo-theme-next.git themes/next 配置博客 1.用户信息配置 根据个人需求进行相关配置。 注意：在themes/next目录中的_config.yml中配置一下信息，而非博客根目录下的_config.yml中配置。ps:不过我的有些没起作用的就放到了根目录下的_config.yml中。 2.创建About页面 在根目录下的source文件夹里创建一个about文件夹，然后在about文件夹里新建index.md文件,在文件中添加如下代码，并保存： --- title: 关于我 date: 2016-10-10 15:40:19 --- 具体介绍信息根据个人进行添加。 部署Hexo博客 建站 $ hexo init yourname $ cd yourname $ npm install 配置_config.yml的部署: deploy: type: git repository: git@github.com:liuJinYang6/liuJinYang6.github.io.git branch: master 清理缓存 $ hexo clean 生成静态网页 $ hexo g 本地查看效果，执行完后可以通过http://localhost:4000查看本地效果 $ hexo s 部署到git $ hexo d 绑定腾讯云域名 之前在腾讯云买了域名，域名购买成功之后要等待实名认证。 添加CNAME文件 在根目录下的source文件夹下新建CNAME文件，没有后缀。打开CNAME文件，在里面添加你的域名信息，保存之后，重新部署到github pages上。 给github项目添加 在项目的Settings中，添加Custom domain到自己的域名。 给域名添加解析记录 1.ping你自己的yourname.github.io获取到ip地址； 2.打开域名的解析列表，添加两条解析记录； 更换之后，可能需要等一段时间才能生效，差不多就大功告成啦。 ","link":"https://liujinyang6.github.io/post/github-pageshexoteng-xun-yun-yu-ming-bang-ding/"}]}