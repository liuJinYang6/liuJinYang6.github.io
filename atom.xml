<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujinyang6.github.io</id>
    <title>Liu jinyang&apos;s Blog</title>
    <updated>2020-07-13T03:19:17.023Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujinyang6.github.io"/>
    <link rel="self" href="https://liujinyang6.github.io/atom.xml"/>
    <logo>https://liujinyang6.github.io/images/avatar.png</logo>
    <icon>https://liujinyang6.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Liu jinyang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[自动化测试---selenium]]></title>
        <id>https://liujinyang6.github.io/post/zi-dong-hua-ce-shi-selenium/</id>
        <link href="https://liujinyang6.github.io/post/zi-dong-hua-ce-shi-selenium/">
        </link>
        <updated>2020-07-10T09:26:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-前言">一、前言</h3>
<p>自动化测试工具：</p>
<p>功能（UI）自动化----QTP、selenium、appium</p>
<p>性能自动化----Loadrunner、Jmeter</p>
<p>接口自动化----jmeter、postman、souapui、Python、java</p>
<hr>
<h3 id="二-web自动化测试的价值">二、web自动化测试的价值</h3>
<p>1） 自动化测试提高效率，缩短测试工作时间<br>
2） 自动化测试和人工测试相比，每一次测试执行的操作时固定的，非常可靠<br>
3） 自动化测试能加大每一轮回归的力度，提高测试的覆盖率<br>
4） 自动化测试具备更好的重现软件缺陷的能力，具有很强的一致性和可重复性</p>
<hr>
<h3 id="三-开展自动化测试的条件">三、开展自动化测试的条件</h3>
<p>1、手工测试无法完成，需要投入大量的时间和人力</p>
<p>2、需求变更不频繁，比较稳定</p>
<p>3、项目周期足够长</p>
<p>4、自动化测试脚本可复用</p>
<p>5、手工测试基本通过</p>
<hr>
<h3 id="四-自动化测试的原理">四、自动化测试的原理</h3>
<p><strong>手工执行用例：</strong></p>
<p>1、打开浏览器，访问目标网址</p>
<p>2、点击登录，进入登陆页面</p>
<p>3、输入用户名</p>
<p>4、输入密码</p>
<p>5、点击登录</p>
<p>6、验证登陆成功</p>
<p><strong>自动化执行用例：</strong></p>
<p>1、调用API函数（webdriver）启动浏览器，使用get方法访问目标网址</p>
<p>2、通过定位目标对象的属性，使用click操作方法</p>
<p>3、通过定位目标对象的属性，使用send_keys操作方法</p>
<p>4、通过定位目标对象的属性，使用send_keys操作方法</p>
<p>5、通过定位目标对象的属性，使用click操作方法</p>
<p>6、使用断言函数（比较函数），判断是否登录成功</p>
<hr>
<h3 id="五-python-selenium自动化测试环境搭建">五、Python-selenium自动化测试环境搭建</h3>
<p>1、 具备Python3环境</p>
<p>2、使用pip安装selenium</p>
<p>验证Python-selenium环境：</p>
<p>在开发工具中输入<code>from selenium import webdriver</code>不报错即可</p>
<p><strong>webdriver</strong>是什么？</p>
<p>相当于一个库，提供函数使用，selenium集成API编程接口，为动态网页提供良好的web能力</p>
<p>浏览器驱动下载目录：http://chromedriver.storage.googleapis.com/index.html</p>
<ul>
<li>注意：如果找不到对应的版本，就找一个最相近的版本进行下载</li>
</ul>
<p>驱动放置目录：</p>
<p>1-目标浏览器的安装目录下；</p>
<p>2-python的安装目录下；</p>
<p>3-通过指定路径的写法</p>
<p>示例：</p>
<pre><code class="language-python">driver_path = r'C:\User\Liu\AppData\Local\webdriver\chromedriver.exe'

dirver = webdriver.Chrome(executable_path = driver_path)
</code></pre>
<hr>
<h3 id="六-seleniumwebdriver脚本编写">六、selenium—webdriver脚本编写</h3>
<h4 id="浏览器操作函数">浏览器操作函数</h4>
<p><code>driver=webdriver.Chrome()</code>--------------------启动浏览器（第一个字母必须大写）</p>
<p><code>driver.maximize_window()</code>----------------------最大化浏览器</p>
<p><code>driver.minimize_window()</code>-----------------------最小化浏览器</p>
<p><code>driver.back()</code>---------------------------------后退</p>
<p><code>driver.forward()</code>------------------------------前进</p>
<p><code>driver.quit()</code>---------------------------------关闭浏览器</p>
<p><code>driver.close()</code>--------------------------------关闭浏览器</p>
<p><code>drvier.refresh()</code>------------------------------刷新浏览器</p>
<p><code>driver.get(url)</code>-------------------------------访问目标网址</p>
<p><code>time.sleep(4)</code>----------------前提导入--------import time</p>
<ul>
<li>注：</li>
</ul>
<p>1.quit退出且关闭所有有关联的窗口，close是关闭当前的窗口</p>
<p>2.driver.get(url)中的url必须用http开头</p>
<h4 id="元素定位方式">元素定位方式</h4>
<p>id ---------------------------------<code>find_element_by_id(id)</code></p>
<p>class ----------------------------<code>find_element_by_class_name(class)</code></p>
<p>name ---------------------------<code>find_element_by_name(name)</code></p>
<p>link_text ------------------------<code>find_element_by_link_text(link_text)</code></p>
<p>partial_link_text --------------<code>find_element_by_partial_link_text(link_text)</code></p>
<p>tag_name----------------------<code>find_element_by_tag_name(tag_name)</code></p>
<p>xpath ---------------------------<code>find_element_by_xpath(xpath)</code></p>
<p>css ------------------------------<code>find_element_by_css_selector(css_selector)</code></p>
<h4 id="操作方法">操作方法</h4>
<p><code>click()</code>----------------------------点击---强调事件的独立性</p>
<p><code>send_keys(‘xxx’)</code>-----------------在输入框内输入xxx</p>
<p><code>clear()</code>----------------------------清空目标对象上的内容</p>
<p><code>submit()</code>---------------------------提交---强调对表单内容的提交</p>
<p><code>text</code>-------------------------------获取目标对象上的文本信息</p>
<ul>
<li>注：</li>
</ul>
<p>由于脚本执行速度过快，导致一些步骤执行失败，因为页面元素尚未渲染完成，脚本无法定位该对象，固在脚本步骤中添加一些必要的时间等待。</p>
<h4 id="等待函数">等待函数</h4>
<p><code>driver.implicitly_wait(3)</code>----------------<strong>智能等待</strong>，如果3s内元素已渲染完成，剩下的时间不再等待，若没有渲染完成，最大等待时间就为3s，对全局脚本均有效</p>
<p><code>time.sleep(3)</code>----------------<strong>强制等待</strong>，无论3s内元素是否渲染完成，都要强制等待3s，对局部脚本有效</p>
<hr>
<h3 id="七-元素定位">七、元素定位</h3>
<h4 id="xpath定位">Xpath定位</h4>
<p>​		XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初 XPath 的提出的初衷是将其作为一个通用的、介于XPointer与XSLT间的语法模型。但是 XPath 很快的被开发者采用来当作小型查询语言。</p>
<p>Xpath获取方式：</p>
<p>1） F12开发者工具，右键复制Xpath路径</p>
<p>2）手动编写</p>
<ul>
<li>
<p>​	纯标签路径： <strong>position</strong></p>
<p>绝对路径：<code>/html/body/div/div[3]/div[2]/form/input</code></p>
<p>相当路径：<code>//div[2]/form/input</code></p>
</li>
<li>
<p>​    标签和属性结合: <strong>attribute</strong></p>
<p>语法：//标签名[@属性=属性值]</p>
<p>示例：</p>
<p><code>//input[@id=’word’]</code></p>
<p><code>//form/input[@id=’word’]</code>----标签可以有多个，也可以只有一个</p>
<p><code>//div[@class='hotwords']/a[1]&quot;</code>---也可利用上层标签的属性进行定位</p>
</li>
</ul>
<p>参考xpath选择器写法：https://www.w3school.com.cn/xpath/xpath_syntax.asp</p>
<h4 id="css定位">Css定位</h4>
<p>​		层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p>
<p>​		CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。</p>
<p>CSS获取方式：</p>
<p>1） F12开发者工具，右键复制CSS路径</p>
<p>2）手动编写</p>
<ul>
<li>
<p>标签和属性组合：标签名[属性名=属性值]</p>
<p>----标签名可以多个，多个时需要用空格隔开：<code>form input.text</code></p>
<p>----属性可以随意：<code>input[type='text']&quot;</code></p>
<p>示例：<code>Input[class=’xxx’]</code></p>
</li>
<li>
<p>注意：</p>
<p>class/id除了可以采用[属性=属性值]的写法，还可以用专用写法，</p>
<p>通过class编写：<code>标签名.class的属性值</code></p>
<p>通过id编写：<code>标签名#id的值</code></p>
<p>组合 ：<code>标签名#id值.class值</code></p>
</li>
</ul>
<p>参考css选择器写法链接：https://www.w3school.com.cn/cssref/css_selectors.asp</p>
<h4 id="多窗口或框架内定位">多窗口或框架内定位</h4>
<h5 id="切换框架">切换框架</h5>
<p>框架中的元素无法定位时需要切换到框架中在进行定位，且勿忘记跳出框架</p>
<p>函数：</p>
<p><code>driver.switch_to.frame(&quot;xx&quot;)</code>--------进入框架（可用框架的id/name/index，也可用其他定位方式）</p>
<p><code>switch_to.default_content()</code>--------跳出框架（跳出最近进入的框架）</p>
<p>​	示例：</p>
<pre><code class="language-python">id = &quot;abc&quot;

driver.switch_to.frame(&quot;abc&quot;)

name = &quot;auto&quot;

driver.switch_to.frame(&quot;auto&quot;)
</code></pre>
<h5 id="切换窗口">切换窗口</h5>
<p>当测试页面同时出现2个或者以上窗口时候，而且新打开的window有name,可以使用<code>driver.switch_to_window(winHandleID)</code>来进行切换，如果窗口没有name，则需要通过定位浏览器句柄来区分浏览器窗口，然后再根据句柄进入不同的浏览器窗口</p>
<p>函数：</p>
<p><code>driver.switch_to.window(winHandleID)</code>-------------根据窗口name或句柄进入下一个窗口</p>
<p><code>driver.current_window_handle</code>  -------------获取当前窗口句柄</p>
<p><code>driver.window_handles</code> -------------获取当前所有窗口的句柄</p>
<ul>
<li>注意：</li>
</ul>
<p>1.可以通过下标的方式定位到第二个窗口句柄</p>
<pre><code class="language-python">#获取当前窗口句柄
handle1 = driver.current_window_handle
	
#点击下方的一元多宝
driver.find_element_by_link_text(&quot;一元夺宝&quot;).click()

all_handles = driver.window_handles
print(all_handles)

handle2 = all_handles[1]

#进入第二个窗口
driver.switch_to.window(handle2)

</code></pre>
<p>2.通过for循环的方式定位到下一个窗口句柄</p>
<pre><code class="language-python">#获得当前所有打开的窗口的句柄
all_handles = driver.window_handles

#进入注册窗口
for handle in all_handles:
    if handle != handle1:
        driver.switch_to.window(handle2)

</code></pre>
<h4 id="接受弹窗">接受弹窗</h4>
<p><code>driver.switch_to_alert().xx</code>  ---------接受弹出窗口</p>
<p>后接方法：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6821030"> <code>text</code><label class="task-list-item-label" for="task-item-6821030"> ``` text``` ：返回 alert/confirm/prompt 中的文字信息。</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6465980"> <code>accept</code><label class="task-list-item-label" for="task-item-6465980"> ```accept```：点击确认按钮。</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4980625"> <code>dismiss</code><label class="task-list-item-label" for="task-item-4980625"> ```dismiss ```：点击取消按钮，如果有的话</label></li>
</ul>
<p>示例：</p>
<pre><code class="language-python">driver = webdriver.Firefox()
driver.maximize_window()
driver.implicitly_wait(10)
driver.get('http://www.baidu.com')


# 打开搜索设置
#driver.find_element_by_xpath('//div[@id=&quot;lg&quot;]').click()
driver.find_element_by_class_name('setpref').click()

# 保存设置
driver.find_element_by_link_text(u'保存设置').click()

time.sleep(3)

# 接收弹窗
driver.switch_to_alert().accept()

time.sleep(5)

driver.quit()

</code></pre>
<h4 id="鼠标悬停">鼠标悬停</h4>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains
……

# 注意：使用该方法需要先导入包
# 鼠标悬停相“设置”链接
link = driver.find_element_by_link_text(u'设置')

ActionChains(driver).move_to_element(link).perform()

#继续点击即可

</code></pre>
<h4 id="下拉菜单的定位方式">下拉菜单的定位方式</h4>
<p>先定位下拉框作为一个对象n，然后再根据value值定位该具体的选项。</p>
<pre><code class="language-python"># 选择省份
n=driver.find_element_by_id(&quot;province&quot;)

n.find_element_by_xpath(&quot;//option[@value='10']&quot;).click()	


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loadrunner脚本常用函数]]></title>
        <id>https://liujinyang6.github.io/post/loadrunner-jiao-ben-chang-yong-han-shu/</id>
        <link href="https://liujinyang6.github.io/post/loadrunner-jiao-ben-chang-yong-han-shu/">
        </link>
        <updated>2020-07-10T06:23:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="web_url">web_url()</h3>
<p>作用：模拟浏览器发出访问目标网址的请求=get 请求</p>
<p>语法：Web_url(“步骤名称”,“url=http：//xxxxx”,LAST);</p>
<p>eg:</p>
<p>web_url(“访问 baidu”，“url=http://www.baidu.com”，LAST);</p>
<hr>
<h3 id="web_submit_data">Web_submit_data()</h3>
<p>作用：向服务器提交表单数据,支持 post 和 get 方法</p>
<hr>
<h3 id="web_custom_request">web_custom_request()</h3>
<p>作用：自定义向服务器发送 http请求，支持的任意方法的请 求，可以代替<code>web_url</code> 和 <code>web_submit_data</code> 函数</p>
<hr>
<h3 id="web_reg_save_param">web_reg_save_param()</h3>
<p>作用：通过目标对象的左右边界获取服务器返回的动态数据</p>
<p>方法：工具栏→insert→new step 输入 <code>web_reg_save_param</code>，点击确定</p>
<p>步骤：</p>
<p>1、 确定需要关联的对象（动态的、变化的，服务器发送给客户端的）</p>
<p>2、 使用 httpwatch/fiddler 抓取目标对象，来确定该数据是由哪个请求产生的</p>
<p>3、 获取目标对象的左右边界，及请求的位置</p>
<p>4、 填写关联函数的参数名称，左右边界、查找数、查找位置</p>
<p>5、 用该参数名替换需要向服务器提交的动态数据，引用参数：{参数名}</p>
<ul>
<li>注意：从名称上知道关联函数是<code>注册型</code>函数，所以应该放在产生动态数据请求的前面，save_param 表示关联函数获取下来之后保存为一个参数，所以脚本中引用时应该加{} 。</li>
</ul>
<hr>
<h3 id="数组操作">数组操作</h3>
<pre><code class="language-c">//返回参数数组指定位置的参数的值  
lr_paramarr_idx(&quot;Did&quot;,1);  

//返回参数数组的元素（参数）的个数  
lr_paramarr_len(&quot;Did&quot;);  

//返回参数数组随机位置的参数的值  
lr_paramarr_random(&quot;Did&quot;); 
</code></pre>
<hr>
<h3 id="lr_think_time">lr_think_time（）</h3>
<p>作用：等待n秒</p>
<p>用法：lr_think_time（n）</p>
<hr>
<h3 id="事务函数">事务函数</h3>
<p>开始事务：lr_start_transaction(&quot;open&quot;);</p>
<p>结束事务：lr_end_transaction(&quot;open&quot;, LR_AUTO);</p>
<p>事务时间=响应时间+思考时间+浪费时间+函数自身执行时间，指的是客户端发出请 求到得到响应的整个过程所经历的时间。</p>
<p>事务的四种状态：<code>LR_AUTO</code>,<code>LR_STOP</code>,<code>LR_PASS</code>,<code>LR_FAIL</code></p>
<p>LR_AUTO: 系统自动判断依赖 http 返回的状态码,状态码为200事务就通过</p>
<hr>
<h3 id="检查点函数">检查点函数</h3>
<p>文本检查点函数，优先使用</p>
<p>Web_reg_find()</p>
<ul>
<li>注意：从名称上知道关联函数是<code>注册型</code>函数，所以应该放在检查数据请求的前面</li>
</ul>
<hr>
<h3 id="lr_eval_string">lr_eval_string()</h3>
<p>作用：取出参数的值</p>
<p>语法：lr_eval_string(“<code>{参数名}</code>”)</p>
<hr>
<h3 id="lr_save_string">lr_save_string()</h3>
<p>作用：保存字符串到一个参数</p>
<p>语法：lr_save_string(“<code>value</code>”，<code>参数名</code>);</p>
<hr>
<h3 id="lr_output_message">lr_output_message()</h3>
<p>作用：在控制台打印信息</p>
<hr>
<h3 id="类型转化">类型转化</h3>
<p><code>atoi()</code>：将字符串类型转为整型</p>
<p><code>itoa()</code>：将整型转为字符串类型</p>
<hr>
<h3 id="lr_rendezvous">lr_rendezvous()</h3>
<p>作用：设置集合点</p>
<p>用法：lr_rendezvous(&quot;集合点名称&quot;);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loadrunner脚本编写练习]]></title>
        <id>https://liujinyang6.github.io/post/loadrunner-jiao-ben-bian-xie-lian-xi/</id>
        <link href="https://liujinyang6.github.io/post/loadrunner-jiao-ben-bian-xie-lian-xi/">
        </link>
        <updated>2020-07-10T03:40:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="参数关联-检查点设置">参数关联、检查点设置</h3>
<pre><code class="language-c">Action()
{	
	int i;

	// 获取动态sessionid
	web_reg_save_param(&quot;sessionid&quot;,
		&quot;LB=&lt;input type=hidden name=userSession value=&quot;,
		&quot;RB=&gt;&quot;,
		&quot;Ord=1&quot;,
		&quot;Search=All&quot;,
		LAST);



	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:1080/WebTours/&quot;,LAST);

	// 设置登录检查点
    
	web_reg_find(&quot;Search=All&quot;,
		&quot;SaveCount=checkcount&quot;,
		&quot;Text=liang01&quot;,
		LAST);

	lr_start_transaction(&quot;login&quot;);

	web_submit_data(&quot;web_submit_data&quot;,
		&quot;Action=http://127.0.0.1:1080/WebTours/login.pl&quot;,
		&quot;Method=POST&quot;,
		&quot;TargetFrame=&quot;,
		&quot;Referer=&quot;,
		ITEMDATA,
		&quot;Name=userSession&quot;, &quot;Value={sessionid}&quot;, ENDITEM,
		&quot;Name=username&quot;, &quot;Value=liang01&quot;, ENDITEM,
		&quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM,
		LAST);
    
	// 将字符串转化为int
    
	i = atoi(lr_eval_string(&quot;{checkcount}&quot;));

	if (i&gt;0) {

		lr_end_transaction(&quot;login&quot;,LR_PASS);

	}
	else{
		lr_end_transaction(&quot;login&quot;,LR_FAIL);
	}



	return 0;
}

</code></pre>
<hr>
<h3 id="参数使用">参数使用</h3>
<pre><code class="language-c">Action()
{
	
	//将字符串&quot;test&quot;保存名为canshu的参数
	//将值存为参数
	lr_save_string(&quot;test&quot;,&quot;canshu&quot;);

 	lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;));

	lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;));
	
	//提取canshu参数的值
	//将值从参数中取出
	lr_eval_string(&quot;{canshu}&quot;);
}
</code></pre>
<hr>
<h3 id="高级关联">高级关联</h3>
<pre><code class="language-c">Action()
{

    // 关联获取大类
	web_reg_save_param(&quot;Did&quot;,
		&quot;LB=categoryId=&quot;,
		&quot;RB=\&quot;&gt;&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);


	// 访问首页
	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST);

	// 将一个字符串定义成一个参数
	// 随机获取数组某一元素的值
	lr_save_string(lr_paramarr_random(&quot;Did&quot;),&quot;did&quot;);
	
	
	// 根据索引获得数组某一元素的值 
    //lr_save_string(lr_paramarr_idx(&quot;Did&quot;,1),&quot;did&quot;);

	// 随机点击大类
	web_url(&quot;catlog&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={did}&quot;,LAST);

	return 0;
}

</code></pre>
<hr>
<h3 id="练习脚本">练习脚本：</h3>
<h4 id="按顺序点击访问页面">按顺序点击访问页面</h4>
<pre><code class="language-c">Action()
{
	int i;
	
	web_reg_save_param(&quot;fidarr&quot;,
		&quot;LB=forumdisplay&amp;fid=&quot;,
		&quot;RB=\&quot;&gt;&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);

	
	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);


	for (i=1;i&lt;=5;i++) {
		
		lr_save_string(lr_paramarr_idx(&quot;fidarr&quot;,i*(int)2),&quot;fid&quot;);

		web_url(&quot;catalog&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php?mod=forumdisplay&amp;fid={fid}&quot;,LAST);

	}


	return 0;
}

</code></pre>
<h4 id="随机登录账号">随机登录账号</h4>
<pre><code class="language-c">Action()
{
	int i = 0;

	web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);
    


	lr_start_transaction(&quot;login&quot;);

	web_submit_data(&quot;login&quot;,
		&quot;Action=http://127.0.0.1:8888/discuz/upload/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&quot;,
		&quot;Method=POST&quot;,
		&quot;TargetFrame=&quot;,
		&quot;Referer=&quot;,
		ITEMDATA,
		&quot;Name=fastloginfield&quot;, &quot;Value=username&quot;, ENDITEM,
		&quot;Name=username&quot;, &quot;Value={username}&quot;, ENDITEM,
		&quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM,
		&quot;Name=quickforward&quot;, &quot;Value=yes&quot;, ENDITEM,
		&quot;Name=handlekey&quot;, &quot;Value=ls&quot;, ENDITEM,
		LAST);

	

	web_reg_find(&quot;Search=All&quot;,
		&quot;SaveCount=namecount&quot;,
		&quot;Text={username}&quot;,
		LAST);


	web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);


	i = atoi(lr_eval_string(&quot;{namecount}&quot;));

	
	if (i&gt;0) {
		lr_end_transaction(&quot;login&quot;,LR_PASS);
		lr_output_message(&quot;namecount的值为%d,出现次数大于0，事务通过&quot;,i);
	}
	else{
		lr_end_transaction(&quot;login&quot;,LR_FAIL);
		lr_output_message(&quot;namecount的值为%d，出现次数为0，事务失败&quot;,i);
	}
	


	return 0;
}

</code></pre>
<h4 id="随机点击任意一个大类再顺序点击其下的小类">随机点击任意一个大类，再顺序点击其下的小类</h4>
<pre><code class="language-c">Action()
{
	int i;

	web_reg_save_param(&quot;catalog_Big&quot;,
	&quot;LB=hidCategoryId\&quot; value=\&quot;&quot;,
	&quot;RB=\&quot; /&gt;&lt;/td&gt;&quot;,
	&quot;Ord=all&quot;,
	&quot;Search=All&quot;,
	LAST);



	web_url(&quot;petshop&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST);


	lr_save_string(lr_paramarr_random(&quot;catalog_Big&quot;),&quot;catalog&quot;);

	
	
	web_reg_save_param(&quot;catalog_Small&quot;,
		&quot;LB=&lt;a href='Items.aspx?productId=&quot;,
		&quot;RB=&amp;categoryId=&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);


	web_url(&quot;random_catalog_big&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={catalog}&quot;,LAST);


	  for (i=1;i&lt;=4;i++) {
		//获取小类的catalogId对应的值
		 lr_save_string(lr_paramarr_idx(&quot;catalog_Small&quot;,i*(int)2),&quot;catalog_small&quot;);

		
		web_submit_data(&quot;web_submit_data&quot;,
			&quot;Action=http://127.0.0.1/pet/Items.aspx&quot;,
			&quot;Method=GET&quot;,
			&quot;TargetFrame=&quot;,
			&quot;Referer=&quot;,
			ITEMDATA,
			&quot;Name=productId&quot;, &quot;Value={catalog_small}&quot;, ENDITEM,
			&quot;Name=categoryId&quot;, &quot;Value={catalog}&quot;, ENDITEM,
			LAST);


	  }


	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Appium教程]]></title>
        <id>https://liujinyang6.github.io/post/appium-jiao-cheng/</id>
        <link href="https://liujinyang6.github.io/post/appium-jiao-cheng/">
        </link>
        <updated>2020-06-17T07:14:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-appium介绍">一、Appium介绍</h2>
<p><code>Appium</code>是一款开源的自动化测试工具，其支持 iOS和安卓平台上的原生的，基于移动浏览 器的，混合的应用。</p>
<p>1、 使用 <code>Appium</code>进行自动化测试的好处</p>
<p>​       <code>Appium</code>在不同平台中使用了标准的自动化 APIs，所以在跨平台时，不需要重新编译或者 修改自己的应用。<br>
​       <code>Appium</code>支持 Selenium WebDriver支持的所有语言，如 java、Object-C、JavaScript、Php、 Python、Ruby、C#、，或者 Perl 语言，更可以使用 Selenium WebDriver 的 Api。<code>Appium</code>支持任何一种测试框架。<code>Appium</code>实现了真正的跨平台自动化测试。（本文主要介绍 Python的用法）</p>
<p>2、<code>Appium</code>架构</p>
<p>​      <code>Appium</code> 是一个用 Node.js编写的HTTP server，它创建、并管理多个 WebDriver sessions 来 和不同平台交互，如 iOS ，Android 等等.</p>
<p>​      <code>Appium</code> 开始一个测试后，就会在被测设备（手机）上启动一个 server ，监听来自 Appium server的指令. 每种平台像 iOS 和 Android 都有不同的运行、和交互方式。所以 <code>Appium</code> 会用某个桩程序“侵入”该平台，并接受指令，来完成测试用例的运行。</p>
<hr>
<h2 id="二-appium安装">二、Appium安装</h2>
<p>1、安装JDK，配置JDK 环境</p>
<p>打开计算机-&gt;系统属性-&gt;高级系统设置-&gt;环境变量-&gt;新建（系统变量），如图所示：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DDT框架]]></title>
        <id>https://liujinyang6.github.io/post/ddt-kuang-jia/</id>
        <link href="https://liujinyang6.github.io/post/ddt-kuang-jia/">
        </link>
        <updated>2020-03-20T06:18:35.000Z</updated>
        <content type="html"><![CDATA[<p>​		<br>
​		<strong>数据驱动</strong>的单元测试是为数据源中的每一行重复运行的一种单元测试。<strong>数据驱动</strong>的单元测试的常用情况是使用多个输入值测试 API。不是编写调用 API 的多个单元测试（每个单元测试均具有一组新的输入），也不是在单元测试中创建一个数组并使用循环代码，而是可以编写执行 API 的单个单元测试方法。然后可以从数据库表的行中进行数据检索以便传递给该测试方法的连续调用。可以使用此技术测试由不同用户（每个用户具有不同角色）使用的应用程序。对于每个用户，数据源中的一行将根据角色指示预期响应。然后，该测试将通过针对每个用户运行功能，对该应用程序进行测试，并验证产生的响应是否与预期响应一致。</p>
<p>​		在测试工作中，针对某一API接口，或者某一个用户界面的输入框，需要设计大量相关的用例，每一个用例包含实际输入的各种可能的数据。通常的做法是，将测试数据存放到一个数据文件里，然后从数据文件读取，在脚本中循环输入测试数据，并对结果进行验证。</p>
<p>​		<code>ddt</code>是结合<code>unittest</code>框架来工作的，所以要先具备<code>unittest</code>框架的知识。</p>
<hr>
<h2 id="使用步骤">使用步骤</h2>
<p>1.导入ddt包</p>
<p>2.用装饰器装饰@ddt</p>
<p>3.传入参数，执行</p>
<hr>
<h2 id="传参示例">传参示例</h2>
<h3 id="传参方式一单个传参">传参方式一：单个传参</h3>
<pre><code class="language-python"># 单个传参

import unittest
from ddt import ddt,data,unpack


@ddt
class MyTestCase1(unittest.TestCase):
    
    # 2,3,4会分别按照执行次数传入，比如第一次执行方法传入2，第二次执行方法传入3,第三次......
    @data(2, 3, 4)
    def test_normal(self, value):
        
        print(value)
        
        self.assertEqual(value, 2)

        
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
<hr>
<h3 id="传参方式二元组-列表-字典传参">传参方式二：元组、列表、字典传参</h3>
<pre><code class="language-python"># 元组、列表、字典传参

import unittest
from ddt import ddt,data,unpack


@ddt
class MyTestCase2(unittest.TestCase):
    
    # 会依次按照执行次数传入，比如第一次执行该方法传入（1，2），第二次传入（2，3）
    @data((1, 2), (2, 3))
    @unpack  # 只有需要进行分发参数的时候才需要添加。1分发给value1，2分发给value2
    def test_tuple(self, value1, value2):
        
        print(&quot;tuple:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
     
    @data([1, 2], [2, 3])
    @unpack
    def test_list(self, value1, value2):
        
        print(&quot;list:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
    
    @data({'value1':1, 'value2':2}, {'value1':2, 'value2':3})
    @unpack   # 入参参数名必须和字典key值一致，否则会报错
    def test_dict(self, value1, value2):
        
        print(&quot;dictionary:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
     
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
<hr>
<h3 id="传参方式三json文件传参">传参方式三：json文件传参</h3>
<pre><code class="language-python"># 传入json

import unittest
from ddt import ddt,data,unpack,file_data


@ddt
class MyTestCase3(unittest.TestCase):
    
    @file_data('E:\\test.json')
    def test_file(self, value):
        
        print(&quot;json file:&quot;,value)
        
 
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unittest教程]]></title>
        <id>https://liujinyang6.github.io/post/unittest-jiao-cheng/</id>
        <link href="https://liujinyang6.github.io/post/unittest-jiao-cheng/">
        </link>
        <updated>2020-03-16T06:33:33.000Z</updated>
        <content type="html"><![CDATA[<p>Python中有一个自带的单元测试框架是<code>unittest</code>模块，用它来做单元测试，它里面封装好了一些校验返回的结果方法和一些用例执行前的初始化操作。在说unittest之前，先说几个概念：</p>
<p><code>TestCase</code> 也就是测试用例</p>
<p><code>TestSuite</code> 多个测试用例集合在一起，就是TestSuite</p>
<p><code>TestLoader</code>是用来加载TestCase到TestSuite中的</p>
<p><code>TestRunner</code>是来执行测试用例的,测试的结果会保存到TestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息</p>
<p>下面我们分别来解释这四个概念的意思，先来看一张unittest的静态类图。</p>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592375687634.png" alt="" loading="lazy"></figure>
<p>一个<code>TestCase</code>的实例就是一个测试用例。什么是测试用例呢？就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)。单元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证。</p>
<p>而多个测试用例集合在一起，就是<code>TestSuite</code>，而且TestSuite也可以嵌套TestSuite。</p>
<p><code>TestLoader</code>是用来加载TestCase到TestSuite中的，其中有几个loadTestsFrom__()方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例。</p>
<p><code>TextTestRunner</code>是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法。</p>
<p>测试的结果会保存到TextTestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息。</p>
<p>一个class继承了unittest.TestCase，便是一个测试用例，但如果其中有多个以 test 开头的方法，那么每有一个这样的方法，在load的时候便会生成一个TestCase实例，如：一个class中有四个test_xxx方法，最后在load到suite中时也有四个测试用例。</p>
<hr>
<p>在每一个测试用例中可以重写 以下函数 :</p>
<p><code>setUp()</code>该测试用例执行前的设置工作、</p>
<p><code>tearDown()</code>该测试用例执行后的清理工作、</p>
<p><code>setUpClass()</code>所有测试用例前的设置工作、</p>
<p><code>tearDownClass()</code>所有测试用例执行后的清洗工作</p>
<hr>
<p>在每一个测试用例中可以通过<code>skip</code>，<code>skipIf</code>，<code>skipUnless</code>装饰器跳过某个测试函数，或者用TestCase.skipTest方法跳过测试函数。</p>
<pre><code class="language-python">@unittest.skip()

@unittest.skipIf()

@unittest.skipUnless()
</code></pre>
<hr>
<p>到这里unittest的整个流程就清楚了：</p>
<p>写好<code>TestCase</code>，然后由<code>TestLoader</code>加载<code>TestCase</code>到<code>TestSuite</code>，然后由<code>TextTestRunner</code>来运行<code>TestSuite</code>，运行的结果保存在<code>TextTestResult</code>中。</p>
<p>我们通过命令行或者<code>unittest.main()</code>执行时，main会自动调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。</p>
<p>加个说明：</p>
<p>1、<code>TestLoader</code>加载<code>TestCase</code>到<code>TestSuite</code>可以通过<code>TestSuite</code>实例对象的<code>addTest()</code>和<code>addTests()</code>方法向suite中添加case或suite</p>
<p>2、在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）。</p>
<p>3、在进行测试时可以传递verbosity参数，用以控制执行结果的输出，0 是简单报告、1 是一般报告、2 是详细报告。</p>
<hr>
<p><strong>被测方法</strong>：</p>
<p>这里我们随意写几个业务函数，表示我们将要进行测试的功能函数。将功能函数文件存储成myfun.py</p>
<pre><code class="language-python"># 被测函数示例
# 保存为mufun.py


def add(a, b):
    
    return a + b


def minus(a, b):
    
    return a - b


def multi(a, b):
    
    return a * b


def divide(a, b):
    
    return a / b
</code></pre>
<p><strong>TestCase测试用例</strong>:</p>
<p>我们通过测试用例用代码来实现每一个测试的详细过程和针对测试目标要测试的内容。同目录下创建test_myfun.py</p>
<pre><code class="language-python"># 测试用例示例


class TestMyFun(unittest.TestCase):
    
    # TestCase基类方法，所有case执行之前自动执行
    @classmethod
    def setUpClass(cls):
        
        print(&quot;这里是所有测试用例前的准备工作&quot;)
        
    
    # TestCase基类方法，所有case执行之后自动执行
    @classmethod
    def tearDownClass(cls):
        
        print(&quot;这里是所有测试用例后的清理工作&quot;)
        
    
    # TestCase基类方法，每次执行case前自动执行
    def setUp(self):
        
        print(&quot;这里是一个测试用例前的准备工作&quot;)
        
    
    # TestCase基类方法，每次执行case后自动执行
    def tearDown(self):
        
        print(&quot;这里是一个测试用例后的清理工作&quot;)
        
        
    @unittest.skip(&quot;我想临时跳过这个测试用例&quot;)
    def test_add(self):                   # 测试add()函数
        
        self.assertEqual(3, add(1, 2))
		
        self.assertNotEqual(3, add(2, 2))
    
    
    def test_minus(self):                 # 测试minus()函数
        
        self.skipTest(&quot;跳过这个测试用例&quot;)
        
        self.assertEqual(1, minus(3, 2))
        
     
     def test_multi(self):                # 测试multi()函数
            
         self.assertEqual(6, multi(2, 3))  
     
    
     def test_divide(self):               # 测试divide()函数
            
         self.assertEqual(2, divide(6, 3))
        
         self.assertEqual(2.5, divide(5, 2))
 

if __name__ == &quot;__main__&quot;:
    
    unittest.main(verbosity=2)
    
    
</code></pre>
<ul>
<li>注意：</li>
</ul>
<p>skip装饰器一共有三个 <code>unittest.skip(reason)</code>、<code>unittest.skipIf(condition,reason)</code>、<code>unittest.skipUnless(condition,reason)</code>，其中<strong>skip</strong>是无条件跳过，<strong>skipIf</strong>是当condition为True时跳过，<strong>skipUnless</strong>是当condition为False时跳过。</p>
<p>每个测试方法<strong>必须</strong>以 <strong>test</strong> 开头，否则是不被unittest识别的。其实每一个test开头的方法都会加载为独立的测试用例。</p>
<p>在unittest.main()中加 <strong>verbosity</strong> 参数可以控制输出的错误报告的详细程度，默认是 1；如果设为 0，则不输出每一用例的执行结果；如果参数为2则表示输出详细结果。</p>
<hr>
<h3 id="testsuite测试套件">TestSuite测试套件</h3>
<p><code>TestSuite</code>用来控制多个测试用例和多个测试文件之间的测试顺序。（这里的示例中的几个测试方法并没有一定关系，但之后你写的用例可能会有先后关系，需要先执行方法A，再执行方法B），我们添加到TestSuite中的case是会按照添加的顺序执行的。</p>
<h4 id="一-创建测试套件">一、创建测试套件</h4>
<p>语法：1.<strong>实例化</strong>、2.调用 <code>addTest()</code>方法</p>
<pre><code class="language-python"># 1.实例化Testsuite类
# 注：TestSuite()主要用来创建测试套件集合
suite = unittest.TestSuite()           

# 2.调用addTest()添加测试方法
# 添加语法：suite.addTest(文件名.类名(‘类中的方法名’))
suite.addTest(TestCount('test_add'))  

# 调用TestSuite类中的addTest：suite.addTest(类名(‘类中的方法名’))
# 执行顺序是按照添加的顺序执行，先添加的先执行

</code></pre>
<ul>
<li>注：test_add是unittest脚本中的被测方法，如果是添加被导入模块中的方法，则需要指定哪个文件名。</li>
<li>suite.addTest(文件名.类名(‘类中的方法名’))</li>
</ul>
<h4 id="二-运行测试套件texttestrunner">二、 运行测试套件TextTestRunner()</h4>
<p>语法：1.<strong>实例化</strong>、 2.调用<code>run()</code>方法</p>
<pre><code class="language-python"># 1.实例化TextTestRunner类
runner = unittest.TextTestRunner()    

# 2.调用Testsuite类中的addTest方法
runner.run(suite)             

</code></pre>
<ul>
<li>注：<strong>TextTestRunner()<strong>主要用来运行</strong>测试套件</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>坑</strong>：<a href="https://www.cnblogs.com/kaerxifa/p/11046156.html">使用Unittest做单元测试，addTest（）单个case的时候却执行全部的case</a></p>
<p>首先造成这个结果的原因是pycharm配置问题</p>
</li>
</ul>
<p>测试代码：</p>
<pre><code class="language-python">import unittest


class Testadd(unittest.TestCase):

    def setUp(self):
        self.a = 20
        self.b = 10

        
    def test_add(self):
        result = self.a + self.b
        self.assertEqual(result,30)
    
    
    def test_sub(self):
        result = self.a -self.b
        self.assertEqual(result,10)


if __name__ == &quot;__main__&quot;:
    suite = unittest.TestSuite()
    suite.addTest(Testadd(&quot;test_add&quot;))
    runner = unittest.TextTestRunner()
    runner.run(suite)

</code></pre>
<p>pycharm执行结果：</p>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1592375744115.png" alt="" loading="lazy"></figure>
<p>命令行执行结果：</p>
<figure data-type="image" tabindex="3"><img src="https://liujinyang6.github.io/post-images/1592375752876.png" alt="" loading="lazy"></figure>
<p><strong>问题解决：</strong></p>
<ol>
<li>
<p>点击pycharm的右上角下拉菜单，点击Edit configurations</p>
</li>
<li>
<p>将Python tests里的对应文件的py.test for...或者unittest for...的文件删除（选中后点击左上角的减号）</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://liujinyang6.github.io/post-images/1592375874971.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>点击+，在下拉菜单中选择Python，然后在右边的script path里...选中所要运行的文件</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://liujinyang6.github.io/post-images/1592375885340.png" alt="" loading="lazy"></figure>
<ol>
<li>最后点击ok即可，再在所要运行的文件处（最好是main处）点击右键就会发现run unittest变成了run</li>
</ol>
<p>再次在pycharm中运行，well done</p>
<figure data-type="image" tabindex="6"><img src="https://liujinyang6.github.io/post-images/1592376021514.png" alt="" loading="lazy"></figure>
<p>总结：</p>
<p>执行unittest in demoSingle就会运行全部case</p>
<figure data-type="image" tabindex="7"><img src="https://liujinyang6.github.io/post-images/1592376034418.png" alt="" loading="lazy"></figure>
<p>而如果运行py文件本身就会只运行addsuite添加的用例</p>
<figure data-type="image" tabindex="8"><img src="https://liujinyang6.github.io/post-images/1592376044986.png" alt="" loading="lazy"></figure>
<hr>
<h4 id="三-单元测试框架实现模块整合-discover方法">三、单元测试框架实现模块整合---discover方法</h4>
<p>遍历所有测试脚本实现整合</p>
<p>使用测试套件单独管理全部功能的用例，利用测试套件整合</p>
<h5 id="testloader"><strong>TestLoader</strong></h5>
<p>该类根据各种标准负责加载测试用例，并返回给测试套件。正常情况下没有必要创建这个类的实例。unittest 提供了可以共享了 defaultTestLoader 类，可以使用其子类和方法创建实例，所以我们可以使用其下面的 discover()方法来创建一个实例。</p>
<p>既：</p>
<pre><code class="language-python">discover = unittest.defaultTestLoader.discover(start_dir，pattern='test*.py'，top_level_dir=None)



discover = unittest.TestLoader().discover(start_dir，pattern='test*.py'，top_level_dir=None)


#运行方法同上(上述方法2选1)
runner = unittest.TextTestRunner()

runner.run(discover)


</code></pre>
<p>找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。</p>
<p><code>start_dir</code> ：要测试的模块名或测试用例目录。（采用双斜线或目录前加r）</p>
<p><code>pattern='test*.py'</code>：表示用例文件名的匹配原则。星号“*”表示任意多个字符。</p>
<p><code>top_level_dir=None</code>：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是在该目录下则需要分别指定），默认为 None。</p>
<ul>
<li>注：<strong>discover</strong>发现的py文件不能控制先后顺序，只能通过文件名字的assccii码值来判断先后运行顺序，所以文件命名的时候可以通过testA……等来定义</li>
</ul>
<hr>
<h4 id="总结单元测试的执行方法一共有3种">总结：单元测试的执行方法一共有3种：</h4>
<p>第一种：通过<code>unittest.main()</code>加载全部test开头的用例并自动执行</p>
<p>第二种：通过添加测试套件的方法<code>addTest</code>，然后运行添加好的测试套件</p>
<p>第三种：通过<code>testloader</code>来加载指定目录下的test开头的用例，运行添加好的<code>discover</code></p>
<hr>
<h3 id="测试报告">测试报告</h3>
<p>1、通过打开/写入文件，编写测试报告</p>
<p>​	自己完成</p>
<p>2、通过 HTMLTestRunner.py 来生成测试报告。</p>
<p><code>HTMLTestRunner</code> 是 Python 标准库的 unittest 单元测试框架的一个扩展。它生成易于使用的 HTML 测试报告。 <code>HTMLTestRunner</code>是在 BSD 许可证下发布。</p>
<hr>
<h4 id="htmltestrunner">HTMLTestRunner</h4>
<p>首先要下 HTMLTestRunner.py 文件，下载地址：</p>
<p>http://tungwaiyip.info/software/HTMLTestRunner.html</p>
<p>HTMLTestRunner.py 本是一个.py 文件，将它放到 Python 安装目录下即可调用。</p>
<pre><code class="language-python"># 语法：
# 首先引入HTMLTestRunner包
import HTMLTestRunner

# 用法：
# 1----------定义个报告存放路径
filename = 'C:\\test_object\\report\\result.html'

# 2----------定义一个文件名，以写方式打开
fp = open(filename, 'wb')

# 3----------定义测试报告
runner =HTMLTestRunner.HTMLTestRunner(
		stream=fp,
		title=u'百度搜索测试报告',
		description=u'用例执行情况：')

# 4----------运行测试用例
runner.run(suite)

# 5----------关闭报告文件
fp.close()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python读写excel文件]]></title>
        <id>https://liujinyang6.github.io/post/python-du-xie-excel-wen-jian/</id>
        <link href="https://liujinyang6.github.io/post/python-du-xie-excel-wen-jian/">
        </link>
        <updated>2020-03-06T03:14:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="用xlrd和xlwt读写excel"><strong>用xlrd和xlwt读写excel</strong></h2>
<p>首先下载安装<strong>xlrd</strong>和<strong>xlwt</strong>这两个库</p>
<hr>
<h3 id="使用xlrd读取excel">使用xlrd读取excel</h3>
<pre><code class="language-python"># 导入包
import xlrd

# 1、打开excel
readbook = xlrd.open_workbook(r'\test\canying.xlsx')

# 2、获取读入的文件的sheet
sheet = readbook.sheet_by_index(1)#索引的方式，从0开始

sheet = readbook.sheet_by_name('sheet2')#通过名字定位sheet页

allsheetnames = readbook.sheet_names()#返回所有sheet页名字组成的列表

# 3、获取sheet的最大行数和列数
nrows = sheet.nrows#行

ncols = sheet.ncols#列

# 4、获取某个单元格的值
lng = sheet.cell(x,y)

lng = sheet.cell(0,0).value#获取1行1列的表格值，从0开始计数

lat = sheet.cell(1,4).value#获取2行5列的表格值，从0开始计数

# 5、获取某行/某列的值
row_value = sheet.row_values(x)  #获取x行的值，从0开始计数

col_value = sheet.col_values(y)  #获取y列的值，从0开始计数

</code></pre>
<hr>
<h3 id="使用xlutilscopy写excel"><strong>使用xlutils.copy写excel</strong></h3>
<pre><code class="language-python"># 导入前，先导入xlrd，需要依赖这个包
from xlutils.copy import copy

# 1-读取源excel中的所有数据（复制对象）
rb = xlrd.open_workbook(excel_dir + '\\' + 'data.xls')

# 2-复制读取的源excel对象
wb = copy(rb)

# 3-通过get_sheet()获取复制对象的sheet页
ws = wb.get_sheet(2)
    
# 4-对sheet页进行写入(传入x和y坐标，和具体写入的value)
ws.write(id,2,real)

ws.write(id,3,status)

# 5-保存excel（具体的excel路径+名称）
wb.save(self.excel_dir + '\\' + 'data.xls')

</code></pre>
<ul>
<li><strong>注意</strong>：运行代码时要关闭excel，否则会报错</li>
</ul>
<hr>
<h2 id="使用openpyxl库读写excel"><strong>使用openpyxl库读写excel</strong></h2>
<p>​	xlrd和xlwt处理的是xls文件，单个sheet最大行数是65535，如果数据量超过65535就会遇到：ValueError: row index was 65536, not allowed by .xls format。</p>
<p>​	如果有更大需要的，建议使用openpyxl函数，最大行数达到1048576。</p>
<pre><code class="language-python"># 导入包
import openpyxl

# 打开excel
file_path = r'D:\work\testdata.xlsx'

inwb = openpyxl.load_workbook(file_path) # 读取文件

# 获取打开的excel的sheet内容
sheetnames = inwb.get_sheet_names()  # 获取所有sheet页的name

ws = inwb.get_sheet_by_name(sheetnames[0])  # 按照name获取第一个sheet页的内容

# 获取sheet的最大行数和列数
rows = ws.max_row
cols = ws.max_column

# 获取某个单元格的值
ws.cell(1, 1).value

# 打开将写的表并添加sheet
outwb = openpyxl.Workbook()   # 打开一个将写的文件

outws = outwb.create_sheet(index=0) # 在将写的文件创建一个新的sheet

# 保存
saveExcel = r'D:\work\new.xlsx'

outwb.save(saveExcel) # 一定要记得保存
</code></pre>
<p><strong>注意</strong>：最后一定要记得保存，否则就前功尽弃喽😲</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python读取config.ini文件]]></title>
        <id>https://liujinyang6.github.io/post/python-du-qu-config-ini-wen-jian/</id>
        <link href="https://liujinyang6.github.io/post/python-du-qu-config-ini-wen-jian/">
        </link>
        <updated>2020-03-01T01:33:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="读取步骤">读取步骤：</h2>
<h2 id="1导入configparser">1.导入configparser</h2>
<pre><code class="language-python">import configparser
</code></pre>
<hr>
<h2 id="2实例化一个configparser对象读取目标配置文件内容">2.实例化一个configparser对象，读取目标配置文件内容</h2>
<pre><code class="language-python"># 1.实例化configparser对象
conf = configparser.ConfigParser()

# 2.获取目标.ini文件路径
file_path = os.path.dirname(‘xxxini文件路径’)+&quot;\\config.ini&quot;

# 3.读取目标文件内的内容(section)，当有中文的时候使用encoding
conf.read(file_path,encoding=&quot;utf-8-sig&quot;)

</code></pre>
<hr>
<ul>
<li>
<h3 id="configini文件格式">config.ini文件格式</h3>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592271873138.png" alt="" loading="lazy"></figure>
<hr>
<ul>
<li>
<h3 id="获取文件内的所有section">获取文件内的所有section</h3>
</li>
</ul>
<pre><code class="language-python">sections = conf.sections()
  
print('获取配置文件所有的section', sections)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的所有option">获取xx section下的所有option</h3>
</li>
</ul>
<pre><code class="language-python">options = conf.options('mysql')

print('获取指定section下所有option', options)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的所有键值对">获取xx section下的所有键值对</h3>
</li>
</ul>
<pre><code class="language-python">items = conf.items('mysql')

print('获取指定section下所有的键值对', items)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的某个option">获取xx section下的某个option</h3>
</li>
</ul>
<pre><code class="language-python">value = conf.get('mysql', 'host')

print('获取指定的section下的option', value)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的邮箱服务器]]></title>
        <id>https://liujinyang6.github.io/post/chang-yong-de-you-xiang-fu-wu-qi/</id>
        <link href="https://liujinyang6.github.io/post/chang-yong-de-you-xiang-fu-wu-qi/">
        </link>
        <updated>2020-02-13T07:21:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-常用的邮箱服务器地址"><strong>一、常用的邮箱服务器地址</strong></h2>
<h3 id="阿里云邮箱mailaliyuncom">阿里云邮箱（mail.aliyun.com）:</h3>
<p>POP3服务器地址:pop3.aliyun.com（SSL加密端口：995；非加密端口：110）</p>
<p>SMTP服务器地址:smtp.aliyun.com（SSL加密端口：465；非加密端口：25）</p>
<p>IMAP服务器地址：imap.aliyun.com（SSL加密端口：993；非加密端口：143）</p>
<p></p>
<hr>
<h3 id="谷歌邮箱googlecom">谷歌邮箱(google.com)：</h3>
<p>POP3服务器地址:pop.gmail.com（SSL启用端口：995）</p>
<p>SMTP服务器地址:smtp.gmail.com（SSL启用端口：587）</p>
<p></p>
<hr>
<h3 id="新浪邮箱sinacom">新浪邮箱（sina.com）:</h3>
<p>POP3服务器地址:pop3.sina.com.cn（端口：110）</p>
<p>SMTP服务器地址:smtp.sina.com.cn（端口：25）</p>
<p></p>
<hr>
<h3 id="tom邮箱topcom">Tom邮箱（top.com）:</h3>
<p>POP3服务器地址:pop.tom.com（端口：110）</p>
<p>SMTP服务器地址:smtp.tom.com（端口：25）</p>
<p></p>
<hr>
<h3 id="网易邮箱163com">网易邮箱（163.com）:</h3>
<p>POP3服务器地址:pop.163.com（端口：110）</p>
<p>SMTP服务器地址:smtp.163.com（端口：25）</p>
<p></p>
<hr>
<h3 id="126邮箱">126邮箱:</h3>
<p>POP3服务器地址：pop.live.com（端口：995）</p>
<p>SMTP服务器地址:smtp.126.com（端口：25）</p>
<p></p>
<hr>
<h3 id="雅虎邮箱yahoocom">雅虎邮箱（yahoo.com）:</h3>
<p>POP3服务器地址:pop.mail.yahoo.com</p>
<p>SMTP服务器地址:smtp.mail.yahoo.com</p>
<p></p>
<hr>
<h3 id="雅虎中国yahoocomcn">雅虎中国（yahoo.com.cn）:</h3>
<p>POP3服务器地址:pop.mail.yahoo.com.cn（端口：995）</p>
<p>SMTP服务器地址:smtp.mail.yahoo.com.cn（端口：587）</p>
<p>雅虎邮箱POP3的SSL不启用端口为110，POP3的SSL启用端口995；SMTP的SSL不启用端口为25，SMTP的SSL启用端口为465。</p>
<p></p>
<hr>
<h3 id="foxmail邮箱foxmailcom">Foxmail邮箱（foxmail.com）：</h3>
<p>POP3服务器地址:POP.foxmail.com（端口：110）</p>
<p>SMTP服务器地址:SMTP.foxmail.com（端口：25）</p>
<p></p>
<hr>
<h3 id="qq邮箱mailqqcom">QQ邮箱（mail.qq.com）</h3>
<p>POP3服务器地址：pop.qq.com（端口：110）</p>
<p>SMTP服务器地址：smtp.qq.com（端口：25）</p>
<p>SMTP服务器需要身份验证。</p>
<p></p>
<hr>
<h3 id="搜狐邮箱sohucom">搜狐邮箱（sohu.com）:</h3>
<p>POP3服务器地址:pop3.sohu.com（端口：110）</p>
<p>SMTP服务器地址:smtp.sohu.com（端口：25）</p>
<p></p>
<hr>
<p></p>
<h3 id="hotmail邮箱hotmailcom">HotMail邮箱（hotmail.com）：</h3>
<p>POP3服务器地址：pop.live.com（端口：995）</p>
<p>SMTP服务器地址：smtp.live.com（端口：587</p>
<p></p>
<hr>
<h3 id="移动139邮箱">移动139邮箱:</h3>
<p>POP3服务器地址：POP.139.com（端口：110）</p>
<p>SMTP服务器地址：SMTP.139.com(端口：25)</p>
<p></p>
<hr>
<h3 id="中华网邮箱chinacom">中华网邮箱（china.com）:</h3>
<p>POP3服务器地址:pop.china.com（端口：110）</p>
<p>SMTP服务器地址:smtp.china.com（端口：25）</p>
<p></p>
<hr>
<p>以上便是常用邮箱SMTP服务器地址大全。可能还有些邮箱木有收集到。我们在设置代收发邮件软件时候，在POP3服务器地址及SMTP服务器地址处，只需要按照以上邮箱对应填写即可。</p>
<h2 id="二-如何打开pop3smtpimap功能">二、如何打开POP3/SMTP/IMAP功能？</h2>
<p>为了保障用户邮箱的安全，QQ邮箱设置了POP3/SMTP/IMAP的开关。系统缺省设置是“关闭”，在用户需要这些功能时请“开启”。</p>
<p>1.首先，登录邮箱，进入设置-帐户；</p>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592551338857.jpg" alt="" loading="lazy"></figure>
<p>然后，在“帐户”设置中，找到设置项，进行设置，如下：</p>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1592551345658.jpg" alt="" loading="lazy"></figure>
<p>最后，保存设置，即打开了相应的服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件测试流程]]></title>
        <id>https://liujinyang6.github.io/post/ruan-jian-ce-shi-liu-cheng/</id>
        <link href="https://liujinyang6.github.io/post/ruan-jian-ce-shi-liu-cheng/">
        </link>
        <updated>2018-12-12T07:10:11.000Z</updated>
        <content type="html"><![CDATA[<p>Posted on 2018-12-12 | In Hexo</p>
<h2 id="需求分析">需求分析：</h2>
<h3 id="-整体流程图">- 整体流程图：</h3>
<p>需求提取 -&gt; 需求分析 -&gt; 需求评审 -&gt; 更新后的测试需求跟踪xmind</p>
<h3 id="-分析流程">- 分析流程：</h3>
<ol>
<li>需求提取：</li>
</ol>
<ul>
<li>分析依据（包括：需求矩阵、产品交互图、需求说明书）</li>
<li>获取需求的纬度
<ul>
<li>客户价值
<ul>
<li>可以为客户带来哪些价值？</li>
<li>可以解决哪些问题？</li>
<li>根据以上问题定位功能是否合理</li>
</ul>
</li>
<li>UI功能 - 展示功能</li>
<li>模块关联-历史模块
<ul>
<li>新功能模块关联</li>
<li>考虑是否关联？耦合部分是否需要支持？</li>
</ul>
</li>
<li>客户使用场景-部署方式
<ul>
<li>网络特性</li>
<li>客户使用服务器常见外设</li>
</ul>
</li>
<li>性能参数-性能要求
<ul>
<li>网卡最低速率</li>
</ul>
</li>
<li>硬件支持</li>
</ul>
</li>
<li>输出（提取最原始的测试需求）</li>
</ul>
<ol>
<li>需求分析：</li>
</ol>
<ul>
<li>
<p>分析依据（五维分析）</p>
<ul>
<li>用户场景</li>
</ul>
<ol>
<li>功能是否和场景强关联</li>
<li>网络拓扑能否满足客户需求</li>
<li>和竞争对手比较差异</li>
<li>功能是否能满足客户实际应用场景</li>
<li>是否考虑了用户的实际操作</li>
</ol>
<ul>
<li>明确性</li>
</ul>
<ol>
<li>范围明确性（参数、类型长度范围）</li>
<li>清晰性限制等范畴</li>
<li>无法预知影响的需求提出进行确定，风险</li>
</ol>
<ul>
<li>二义性</li>
</ul>
<ol>
<li>概念模糊【大概念、第三方支持、与上个版本相同】</li>
<li>支持与不支持等范畴</li>
<li>一个需求描述能出现多种理解</li>
</ol>
<ul>
<li>完整性</li>
</ul>
<ol>
<li>需求一致性【用户需求、需求规格、需求矩阵三者是否同意】</li>
<li>需求完整【隐形需求】</li>
<li>关联性【与新老功能、与外置软件设备】</li>
</ol>
<ul>
<li>可测试性</li>
</ul>
<ol>
<li>实现测试需要的工具、方法【调试、接口命令】</li>
<li>定位方式【日志等形式观察】</li>
<li>复杂环境、容量边界、操作时过程不可见</li>
</ol>
</li>
<li>
<p>输出</p>
<ol>
<li>测试需求跟踪</li>
<li>缺陷预防bug</li>
<li>工具需求</li>
<li>整理出明确的需求点</li>
<li>测试地图</li>
</ol>
</li>
<li>
<p>分析思路误区：需求和实现的区别【现有需求才有代码实现，不能把代码实现当作需求】</p>
</li>
<li>
<p>需求分析的意义</p>
<ol>
<li>明确产品给客户带来的价值</li>
<li>明确产品支持和不支持的功能</li>
<li>明确产品各个功能的约束性</li>
<li>知道开发实现功能</li>
<li>知道测试分析和产出测试点</li>
</ol>
</li>
</ul>
<h2 id="测试设计">测试设计：</h2>
<h3 id="-测试分析">- 测试分析：</h3>
<ul>
<li>
<p>我们需要做什么？</p>
<ol>
<li>把明确的需求点转换成测试项</li>
<li>缺陷预防</li>
</ol>
</li>
<li>
<p>怎么做？</p>
<ol>
<li>整体模块分析</li>
<li>逻辑分析【这一点主要是从产品实现的原理上去分析可能的影响】</li>
</ol>
<ul>
<li>
<p>怎么做？</p>
<ul>
<li>
<p>开发的设计文档</p>
<ul>
<li>补充和挖掘测试点</li>
</ul>
<ol>
<li>全部服务的异常监控、服务重启</li>
<li>各类存储对空间的占用、占满、是否需要做存储的接口测试</li>
<li>所有类型的管理员、操作权限测试、支持的多少管理员并发操作</li>
<li>对流程图的挖掘 – 流程图全部流程测试、流程图重要的节点异常测试</li>
<li>对状态的挖掘 – 所有状态的相互转化需要覆盖全、状态转化是否合理、每一个状态下哪些操作可做哪些不可做，多个状态是否可以共存</li>
<li>对关联项的挖掘 – 流程进展到哪一步关机重启/服务重启、和备份配置的关联，和操作日志的关联等等</li>
<li>任务的并发操作测试、是否可配置、是否会出现性能不足，是否符合用户场景</li>
<li>异常处理机制测试，异常处理机制是否完善</li>
<li>指标测试，开发的指标设计是否合理</li>
</ol>
<ul>
<li>修正不合理的需求</li>
</ul>
</li>
<li>
<p>如何分析</p>
<ul>
<li>逻辑原理：
<ol>
<li>该模块是否涉及到一些全新的概念(比如我们的 bbc 全量包)，需要明确?</li>
<li>该模块包括哪些服务?</li>
<li>该模块涉及到哪些存储技术(如 mysql、dap、redis)?具体怎么存储的?占用大小如何?</li>
<li>该模块的操作流程有哪些?是否有子流程图?</li>
<li>该模块是否有多个状态的转化?是否有明确的状态转化图?</li>
<li>该模块对多个管理员是否区分，管理员权限如何设计?</li>
<li>该模块是否有一些特殊的操作限制?操作限制是否有明确的表格?</li>
<li>该模块的任务是否有并发需求?并发的设计?</li>
<li>该模块的所有指标如何?</li>
<li>该模块是否有异常处理机制?在设备各种异常时，该模块的设计是否满足能稳健运行?</li>
</ol>
</li>
<li>场景分析
<ol>
<li>从用户的使用习惯和使用方法去分析影响</li>
<li>检查当前案例是否覆盖到用户场景</li>
</ol>
</li>
<li>关联测试分析：
<ol>
<li>考虑你的模块所在整个系统的地位，分析上下游的影响</li>
<li>对老功能的影响</li>
</ol>
</li>
<li>经验补充分析
<ol>
<li>版本分析</li>
<li>模块分析</li>
</ol>
</li>
<li>输出
<ol>
<li>测试项</li>
<li>补充测试地图</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-测试设计">- 测试设计：</h3>
<ul>
<li>
<p>需要做什么？</p>
<ol>
<li>把测试项细化成测试点</li>
<li>缺陷预防</li>
</ol>
</li>
<li>
<p>需要做什么？</p>
<ul>
<li>基本设计方法</li>
</ul>
<ol>
<li>等价类划分法【将输入域和输出域划分为不同的等价类，等价类之内的操作结果相同】，使用范围：显示输入框输入</li>
<li>边界值法【需要结合等价类划分法方法，在划分出来的等价类选取有代表性的值】</li>
<li>正反对比【一般会放到同一个用例里覆盖】</li>
<li>字符多样性【考虑不同字符的输入】</li>
<li>测试类型</li>
</ol>
<ul>
<li>产品专项测试</li>
<li>正交组合设计【正交矩阵，覆盖各个参数间的组合情况】</li>
<li>业务逻辑设计【根据业务设计测试点】</li>
</ul>
</li>
<li>
<p>输出：</p>
<ul>
<li>基本测试点</li>
</ul>
</li>
</ul>
<h3 id="-用例设计">- 用例设计：</h3>
<ul>
<li>
<p>需要做什么？</p>
<ul>
<li>把测试点用文字完整表述出来</li>
</ul>
</li>
<li>
<p>怎么做？</p>
<ul>
<li>
<p>功能用例框架：</p>
<ul>
<li>
<p>模块框架模板</p>
<ul>
<li>
<p>需求类</p>
<ul>
<li>
<p>UI测试【如果UI用例可以被功能用例覆盖，这里可以不写】</p>
<ul>
<li>
<p>公共测试类：</p>
<ul>
<li>链接</li>
</ul>
<ol>
<li>选中会有高亮显示</li>
<li>点击跳转到对应页面</li>
<li>当前页面对应的名称下有区别显示</li>
</ol>
<ul>
<li>翻页</li>
<li>按钮</li>
<li>输入框【这个功能用例一般可以覆盖】</li>
<li>下拉框</li>
<li>排序</li>
<li>条目选择【这个很重要，第一次集成测试一定要保证每个选项都是有效的】</li>
<li>搜索</li>
</ul>
<ol>
<li>所有字符类型验证</li>
<li>为空验证</li>
<li>模糊搜索</li>
<li>精确搜索</li>
<li>搜索不存在的关键词</li>
</ol>
<ul>
<li>刷新</li>
</ul>
<ol>
<li>验证自动刷新</li>
<li>验证手动刷新</li>
<li>验证持续刷新</li>
</ol>
<ul>
<li>拖动</li>
<li>移动</li>
</ul>
<ol>
<li>点击下移，往下移动一行</li>
<li>点击上移，往上移动一行</li>
<li>最上面的行，上移不能点击，图标灰色</li>
<li>最下面的行，下移不能点击，图标灰色</li>
</ol>
</li>
<li>
<p>功能测试</p>
<ul>
<li>测试点：</li>
</ul>
<ol>
<li>功能基本流程逻辑覆盖</li>
<li>业务流程多样性覆盖</li>
<li>用户操作习惯的多样性</li>
<li>模块配置的多样性</li>
<li>数据流的多样性覆盖</li>
</ol>
<ul>
<li>测试目录</li>
</ul>
<ol>
<li>平级分类相对独立</li>
<li>上下级分类有关联</li>
<li>下级从上级细化而来</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关联类：</p>
</li>
</ul>
<ol>
<li>模块与模块之间的</li>
<li>模块与功能之间</li>
<li>模块与硬件之间</li>
</ol>
<ul>
<li>
<p>场景类</p>
<ul>
<li>建模思路</li>
</ul>
<ol>
<li>部署方式【比如用户一般使用2主机还是3主机部署集群】</li>
<li>数据流</li>
<li>业务流【用户是怎么使用申请工单，是怎么样的完整流程】</li>
<li>操作顺序【创建云主机的顺序之类的】</li>
<li>配置方法【用户一般怎么配置使用静态路由】</li>
<li>使用时间【用户会不会连续长时间开启云主机】</li>
<li>用户角色【一般那些角色做什么操作】</li>
</ol>
<ul>
<li>用户操作的设计方向</li>
</ul>
<ol>
<li>最常用的功能</li>
<li>最容易出现网上问题的功能</li>
<li>典型客户使用的功能</li>
<li>版本的性能验证</li>
</ol>
</li>
<li>
<p>专项类</p>
<ol>
<li>
<p>兼容性</p>
</li>
<li>
<p>可靠性【测试产品在异常情况下能否正常工作或者是恢复正常工作，可靠性重点测试对模块自身处理的覆盖】. 补充：容错性测试【测试系统在非正常操作、非正常的外部环境下是否能够处理错误和正常运行】</p>
<p>eg：</p>
<ol>
<li>针对数据库的测试：【磁盘空间不足、数据库文件损坏、无读写数据权限、写数据时断电、写数据时强制关闭mysql、读写速度】</li>
<li>针对网络设备：【网络中有攻击数据、丢包时延大、IP冲突、网络线路断开、同时掉电】</li>
<li>针对程序：【 客户端进程被手动停止、设备后台资源cpu、内存占满】</li>
</ol>
</li>
<li>
<p>安全性【主要是验证程序有哪些缺陷可能会造成安全方面的问题】</p>
<p>eg：</p>
<ol>
<li>密码加密方式【什么时候用明文，什么时候用密码显示】</li>
<li>隐私数据隐藏【用户的隐私显示】</li>
<li>设备的完整目录【完整的目录会增加后台被攻击的危险】</li>
<li>文件上传功能【检查上传的文件类型；限制上传文件的权限】</li>
<li>防暴力破解【对于连线认证之类的操作要冻结、禁用其连续错误尝试操作】</li>
</ol>
</li>
<li>
<p>脚本测试</p>
<ul>
<li>
<p>使用注意细节</p>
<ul>
<li>
<p>文件夹以01-xx，02-xx区分开</p>
</li>
<li>
<p>每个文件夹下不能超过10个用例</p>
</li>
<li>
<p>每个测试用例一个测试点</p>
</li>
<li>
<p>在02-功能测试的描述中，备注说明功能测试框架的思路</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-用例整体规范">- 用例整体规范：</h3>
<ul>
<li>
<p>用例标题【好的标题需要准确的表达你的测试目的、要测试的测试点】</p>
<p>eg：</p>
<ul>
<li>测试。。。</li>
<li>验证。。。</li>
<li>。。。的测试</li>
<li>与。。。的关联测试</li>
<li>。。。的异常测试</li>
<li>。。。的兼容性测试</li>
</ul>
</li>
<li>
<p>用例属性</p>
<ol>
<li>测试环境【默认的前置条件可以不用写；写的前置条件要准确，不要写的模糊】</li>
</ol>
</li>
</ul>
<ol>
<li>测试方法
<ol>
<li>优先级
<ul>
<li>BVT【最最最基本的功能】-BVT(10%)：模块最基本的功能验证(含常用部署、基本关联)，推荐1级用例的20%左右</li>
<li>level1【基本操作、基本场景】-Leve1(30%)：基本需求点，基本逻辑，基本可靠性，基本关联，基本用户场景</li>
<li>level2【比较少见的正常操作】-Leve2(40%)：常见功能/逻辑细化点/专项细化点，常见关联/容错/边界值/用户场景</li>
<li>level3【异常操作；后续不需要再执行】-Leve3(20%)：错误提示、极少测试的用例、非常见部署方式/用户场景/容错/边界值等</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>用例格式
<ol>
<li>前置条件</li>
<li>测试步骤【单个用例全部步骤不能超过8步】</li>
<li>后置条件【不是必填的】</li>
<li>预期结果</li>
<li>备注【不是必填的】</li>
</ol>
</li>
<li>语言规范
<ol>
<li>语言简练</li>
<li>不能出现模糊的形容词【比如说大概、可能、很多、差不多】</li>
</ol>
</li>
<li>可维护性
<ol>
<li>灵活运用模块备注</li>
</ol>
</li>
<li>设计原则
<ol>
<li>目的明确【一个用例对应一个测试点；测试步骤和测试目的一致】</li>
<li>用例效率
<ul>
<li>保证设计出来的用例10分钟内可以执行完成；</li>
<li>用例需要的环境可以整理出来，然后写到模块备注中，让执行者先准备好环境一次性执行全部用例；</li>
<li>执行的时候按照测试集方式来执行；</li>
<li>有工具可以实现的用例不要采用脚本方式实现</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li>测试步骤：
<ul>
<li>用户角度
<ol>
<li>设计的用例要符合用户的操作顺序和操作习惯</li>
<li>符合用户的使用环境</li>
<li>符合用户的配置</li>
</ol>
</li>
<li>可执行
<ol>
<li>不要出现那种用例设计没有错，但是执行起来很复杂或者是依赖环境很夸张的用例</li>
</ol>
</li>
<li>正反对比
<ol>
<li>这一点很重要，很多时候我们会把有正反操作的用例分开写，其实是可以合在一个用例里面写</li>
</ol>
</li>
<li>强弱关联
<ol>
<li>对于强关联的步骤一定要写清楚</li>
<li>对于弱关联的可以备注或者是不写</li>
</ol>
</li>
<li>测试用例不能出现操作步骤
<ol>
<li>直接写需要做的操作就可以了</li>
</ol>
</li>
</ul>
</li>
<li>预期结果：</li>
</ol>
<ul>
<li>用户角度：
<ol>
<li>反思用户期望操作完会有什么结果</li>
<li>反思客户最关注的测试点</li>
</ol>
</li>
<li>可检查
<ol>
<li>预期结果要可以观察到，不要写的很模糊</li>
<li>把重点检查的检查点覆盖到</li>
</ol>
</li>
<li>用例编写口诀
<ol>
<li>强弱正反之业务</li>
<li>重点突出之效率</li>
<li>目的明确之语言</li>
<li>框架覆盖之检查</li>
<li>逻辑场景之经验</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
</feed>