<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujinyang6.github.io</id>
    <title>Liu jinyang&apos;s Blog</title>
    <updated>2020-09-17T02:29:13.421Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujinyang6.github.io"/>
    <link rel="self" href="https://liujinyang6.github.io/atom.xml"/>
    <logo>https://liujinyang6.github.io/images/avatar.png</logo>
    <icon>https://liujinyang6.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Liu jinyang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[自动化测试---selenium]]></title>
        <id>https://liujinyang6.github.io/post/zi-dong-hua-ce-shi-selenium/</id>
        <link href="https://liujinyang6.github.io/post/zi-dong-hua-ce-shi-selenium/">
        </link>
        <updated>2020-05-22T09:26:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-前言">一、前言</h3>
<p>自动化测试工具：</p>
<p>功能（UI）自动化----QTP、selenium、appium</p>
<p>性能自动化----Loadrunner、Jmeter</p>
<p>接口自动化----jmeter、postman、souapui、Python、java</p>
<hr>
<h3 id="二-web自动化测试的价值">二、web自动化测试的价值</h3>
<p>1） 自动化测试提高效率，缩短测试工作时间<br>
2） 自动化测试和人工测试相比，每一次测试执行的操作时固定的，非常可靠<br>
3） 自动化测试能加大每一轮回归的力度，提高测试的覆盖率<br>
4） 自动化测试具备更好的重现软件缺陷的能力，具有很强的一致性和可重复性</p>
<hr>
<h3 id="三-开展自动化测试的条件">三、开展自动化测试的条件</h3>
<p>1、手工测试无法完成，需要投入大量的时间和人力</p>
<p>2、需求变更不频繁，比较稳定</p>
<p>3、项目周期足够长</p>
<p>4、自动化测试脚本可复用</p>
<p>5、手工测试基本通过</p>
<hr>
<h3 id="四-自动化测试的原理">四、自动化测试的原理</h3>
<p><strong>手工执行用例：</strong></p>
<p>1、打开浏览器，访问目标网址</p>
<p>2、点击登录，进入登陆页面</p>
<p>3、输入用户名</p>
<p>4、输入密码</p>
<p>5、点击登录</p>
<p>6、验证登陆成功</p>
<p><strong>自动化执行用例：</strong></p>
<p>1、调用API函数（webdriver）启动浏览器，使用get方法访问目标网址</p>
<p>2、通过定位目标对象的属性，使用click操作方法</p>
<p>3、通过定位目标对象的属性，使用send_keys操作方法</p>
<p>4、通过定位目标对象的属性，使用send_keys操作方法</p>
<p>5、通过定位目标对象的属性，使用click操作方法</p>
<p>6、使用断言函数（比较函数），判断是否登录成功</p>
<hr>
<h3 id="五-python-selenium自动化测试环境搭建">五、Python-selenium自动化测试环境搭建</h3>
<p>1、 具备Python3环境</p>
<p>2、使用pip安装selenium</p>
<p>验证Python-selenium环境：</p>
<p>在开发工具中输入<code>from selenium import webdriver</code>不报错即可</p>
<p><strong>webdriver</strong>是什么？</p>
<p>相当于一个库，提供函数使用，selenium集成API编程接口，为动态网页提供良好的web能力</p>
<p>浏览器驱动下载目录：http://chromedriver.storage.googleapis.com/index.html</p>
<ul>
<li>注意：如果找不到对应的版本，就找一个最相近的版本进行下载</li>
</ul>
<p>驱动放置目录：</p>
<p>1-目标浏览器的安装目录下；</p>
<p>2-python的安装目录下；</p>
<p>3-通过指定路径的写法</p>
<p>示例：</p>
<pre><code class="language-python">driver_path = r'C:\User\Liu\AppData\Local\webdriver\chromedriver.exe'

dirver = webdriver.Chrome(executable_path = driver_path)
</code></pre>
<hr>
<h3 id="六-seleniumwebdriver脚本编写">六、selenium—webdriver脚本编写</h3>
<h4 id="浏览器操作函数">浏览器操作函数</h4>
<p><code>driver=webdriver.Chrome()</code>--------------------启动浏览器（第一个字母必须大写）</p>
<p><code>driver.maximize_window()</code>----------------------最大化浏览器</p>
<p><code>driver.minimize_window()</code>-----------------------最小化浏览器</p>
<p><code>driver.back()</code>---------------------------------后退</p>
<p><code>driver.forward()</code>------------------------------前进</p>
<p><code>driver.quit()</code>---------------------------------关闭浏览器</p>
<p><code>driver.close()</code>--------------------------------关闭浏览器</p>
<p><code>drvier.refresh()</code>------------------------------刷新浏览器</p>
<p><code>driver.get(url)</code>-------------------------------访问目标网址</p>
<p><code>time.sleep(4)</code>----------------前提导入--------import time</p>
<ul>
<li>注：</li>
</ul>
<p>1.quit退出且关闭所有有关联的窗口，close是关闭当前的窗口</p>
<p>2.driver.get(url)中的url必须用http开头</p>
<h4 id="元素定位方式">元素定位方式</h4>
<p>id ---------------------------------<code>find_element_by_id(id)</code></p>
<p>class ----------------------------<code>find_element_by_class_name(class)</code></p>
<p>name ---------------------------<code>find_element_by_name(name)</code></p>
<p>link_text ------------------------<code>find_element_by_link_text(link_text)</code></p>
<p>partial_link_text --------------<code>find_element_by_partial_link_text(link_text)</code></p>
<p>tag_name----------------------<code>find_element_by_tag_name(tag_name)</code></p>
<p>xpath ---------------------------<code>find_element_by_xpath(xpath)</code></p>
<p>css ------------------------------<code>find_element_by_css_selector(css_selector)</code></p>
<h4 id="操作方法">操作方法</h4>
<p><code>click()</code>----------------------------点击---强调事件的独立性</p>
<p><code>send_keys(‘xxx’)</code>-----------------在输入框内输入xxx</p>
<p><code>clear()</code>----------------------------清空目标对象上的内容</p>
<p><code>submit()</code>---------------------------提交---强调对表单内容的提交</p>
<p><code>text</code>-------------------------------获取目标对象上的文本信息</p>
<ul>
<li>注：</li>
</ul>
<p>由于脚本执行速度过快，导致一些步骤执行失败，因为页面元素尚未渲染完成，脚本无法定位该对象，固在脚本步骤中添加一些必要的时间等待。</p>
<h4 id="等待函数">等待函数</h4>
<p><code>driver.implicitly_wait(3)</code>----------------<strong>智能等待</strong>，如果3s内元素已渲染完成，剩下的时间不再等待，若没有渲染完成，最大等待时间就为3s，对全局脚本均有效</p>
<p><code>time.sleep(3)</code>----------------<strong>强制等待</strong>，无论3s内元素是否渲染完成，都要强制等待3s，对局部脚本有效</p>
<hr>
<h3 id="七-元素定位">七、元素定位</h3>
<h4 id="xpath定位">Xpath定位</h4>
<p>​		XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初 XPath 的提出的初衷是将其作为一个通用的、介于XPointer与XSLT间的语法模型。但是 XPath 很快的被开发者采用来当作小型查询语言。</p>
<p>Xpath获取方式：</p>
<p>1） F12开发者工具，右键复制Xpath路径</p>
<p>2）手动编写</p>
<ul>
<li>
<p>​	纯标签路径： <strong>position</strong></p>
<p>绝对路径：<code>/html/body/div/div[3]/div[2]/form/input</code></p>
<p>相当路径：<code>//div[2]/form/input</code></p>
</li>
<li>
<p>​    标签和属性结合: <strong>attribute</strong></p>
<p>语法：//标签名[@属性=属性值]</p>
<p>示例：</p>
<p><code>//input[@id=’word’]</code></p>
<p><code>//form/input[@id=’word’]</code>----标签可以有多个，也可以只有一个</p>
<p><code>//div[@class='hotwords']/a[1]&quot;</code>---也可利用上层标签的属性进行定位</p>
</li>
</ul>
<p>参考xpath选择器写法：https://www.w3school.com.cn/xpath/xpath_syntax.asp</p>
<h4 id="css定位">Css定位</h4>
<p>​		层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p>
<p>​		CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。</p>
<p>CSS获取方式：</p>
<p>1） F12开发者工具，右键复制CSS路径</p>
<p>2）手动编写</p>
<ul>
<li>
<p>标签和属性组合：标签名[属性名=属性值]</p>
<p>----标签名可以多个，多个时需要用空格隔开：<code>form input.text</code></p>
<p>----属性可以随意：<code>input[type='text']&quot;</code></p>
<p>示例：<code>Input[class=’xxx’]</code></p>
</li>
<li>
<p>注意：</p>
<p>class/id除了可以采用[属性=属性值]的写法，还可以用专用写法，</p>
<p>通过class编写：<code>标签名.class的属性值</code></p>
<p>通过id编写：<code>标签名#id的值</code></p>
<p>组合 ：<code>标签名#id值.class值</code></p>
</li>
</ul>
<p>参考css选择器写法链接：https://www.w3school.com.cn/cssref/css_selectors.asp</p>
<h4 id="多窗口或框架内定位">多窗口或框架内定位</h4>
<h5 id="切换框架">切换框架</h5>
<p>框架中的元素无法定位时需要切换到框架中在进行定位，且勿忘记跳出框架</p>
<p>函数：</p>
<p><code>driver.switch_to.frame(&quot;xx&quot;)</code>--------进入框架（可用框架的id/name/index，也可用其他定位方式）</p>
<p><code>switch_to.default_content()</code>--------跳出框架（跳出最近进入的框架）</p>
<p>​	示例：</p>
<pre><code class="language-python">id = &quot;abc&quot;

driver.switch_to.frame(&quot;abc&quot;)

name = &quot;auto&quot;

driver.switch_to.frame(&quot;auto&quot;)
</code></pre>
<h5 id="切换窗口">切换窗口</h5>
<p>当测试页面同时出现2个或者以上窗口时候，而且新打开的window有name,可以使用<code>driver.switch_to_window(winHandleID)</code>来进行切换，如果窗口没有name，则需要通过定位浏览器句柄来区分浏览器窗口，然后再根据句柄进入不同的浏览器窗口</p>
<p>函数：</p>
<p><code>driver.switch_to.window(winHandleID)</code>-------------根据窗口name或句柄进入下一个窗口</p>
<p><code>driver.current_window_handle</code>  -------------获取当前窗口句柄</p>
<p><code>driver.window_handles</code> -------------获取当前所有窗口的句柄</p>
<ul>
<li>注意：</li>
</ul>
<p>1.可以通过下标的方式定位到第二个窗口句柄</p>
<pre><code class="language-python">#获取当前窗口句柄
handle1 = driver.current_window_handle
	
#点击下方的一元多宝
driver.find_element_by_link_text(&quot;一元夺宝&quot;).click()

all_handles = driver.window_handles
print(all_handles)

handle2 = all_handles[1]

#进入第二个窗口
driver.switch_to.window(handle2)

</code></pre>
<p>2.通过for循环的方式定位到下一个窗口句柄</p>
<pre><code class="language-python">#获得当前所有打开的窗口的句柄
all_handles = driver.window_handles

#进入注册窗口
for handle in all_handles:
    if handle != handle1:
        driver.switch_to.window(handle2)

</code></pre>
<h4 id="接受弹窗">接受弹窗</h4>
<p><code>driver.switch_to_alert().xx</code>  ---------接受弹出窗口</p>
<p>后接方法：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7989130"> <code>text</code><label class="task-list-item-label" for="task-item-7989130"> ``` text``` ：返回 alert/confirm/prompt 中的文字信息。</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2054528"> <code>accept</code><label class="task-list-item-label" for="task-item-2054528"> ```accept```：点击确认按钮。</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1894069"> <code>dismiss</code><label class="task-list-item-label" for="task-item-1894069"> ```dismiss ```：点击取消按钮，如果有的话</label></li>
</ul>
<p>示例：</p>
<pre><code class="language-python">driver = webdriver.Firefox()
driver.maximize_window()
driver.implicitly_wait(10)
driver.get('http://www.baidu.com')


# 打开搜索设置
#driver.find_element_by_xpath('//div[@id=&quot;lg&quot;]').click()
driver.find_element_by_class_name('setpref').click()

# 保存设置
driver.find_element_by_link_text(u'保存设置').click()

time.sleep(3)

# 接收弹窗
driver.switch_to_alert().accept()

time.sleep(5)

driver.quit()

</code></pre>
<h4 id="鼠标悬停">鼠标悬停</h4>
<pre><code class="language-python">from selenium.webdriver.common.action_chains import ActionChains
……

# 注意：使用该方法需要先导入包
# 鼠标悬停相“设置”链接
link = driver.find_element_by_link_text(u'设置')

ActionChains(driver).move_to_element(link).perform()

#继续点击即可

</code></pre>
<h4 id="下拉菜单的定位方式">下拉菜单的定位方式</h4>
<p>先定位下拉框作为一个对象n，然后再根据value值定位该具体的选项。</p>
<pre><code class="language-python"># 选择省份
n=driver.find_element_by_id(&quot;province&quot;)

n.find_element_by_xpath(&quot;//option[@value='10']&quot;).click()	


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Appium教程]]></title>
        <id>https://liujinyang6.github.io/post/appium-jiao-cheng/</id>
        <link href="https://liujinyang6.github.io/post/appium-jiao-cheng/">
        </link>
        <updated>2020-04-02T07:14:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-appium介绍">一、Appium介绍</h2>
<p><code>Appium</code>是一款开源的自动化测试工具，其支持 iOS和安卓平台上的原生的，基于移动浏览 器的，混合的应用。</p>
<p>1、 使用 <code>Appium</code>进行自动化测试的好处</p>
<p>​       <code>Appium</code>在不同平台中使用了标准的自动化 APIs，所以在跨平台时，不需要重新编译或者 修改自己的应用。<br>
​       <code>Appium</code>支持 Selenium WebDriver支持的所有语言，如 java、Object-C、JavaScript、Php、 Python、Ruby、C#、，或者 Perl 语言，更可以使用 Selenium WebDriver 的 Api。<code>Appium</code>支持任何一种测试框架。<code>Appium</code>实现了真正的跨平台自动化测试。（本文主要介绍 Python的用法）</p>
<p>2、<code>Appium</code>架构</p>
<p>​      <code>Appium</code> 是一个用 Node.js编写的HTTP server，它创建、并管理多个 WebDriver sessions 来 和不同平台交互，如 iOS ，Android 等等.</p>
<p>​      <code>Appium</code> 开始一个测试后，就会在被测设备（手机）上启动一个 server ，监听来自 Appium server的指令. 每种平台像 iOS 和 Android 都有不同的运行、和交互方式。所以 <code>Appium</code> 会用某个桩程序“侵入”该平台，并接受指令，来完成测试用例的运行。</p>
<hr>
<h2 id="二-appium安装">二、Appium安装</h2>
<h3 id="1-安装jdk配置jdk-环境">1、安装JDK，配置JDK 环境</h3>
<p>打开计算机-&gt;系统属性-&gt;高级系统设置-&gt;环境变量-&gt;新建（系统变量），如图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1596166168045.png" alt="" loading="lazy"></figure>
<p>配置<code>JAVA_HOME</code></p>
<p><code>C:\Program Files\Java\jdk1.8.0_181</code>（根据自己的安装磁盘决定盘符）</p>
<p>配置<code>Path</code>：</p>
<p><code>;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin;</code>追加进Path中；</p>
<p>配置<code>CLASSPATH</code></p>
<p><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code></p>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1596166196868.png" alt="" loading="lazy"></figure>
<p>验证一下JDK的环境是否配置好，win+r 输入cmd进入dos下输入java -version检查环境是否配置成功。</p>
<h3 id="2-安装android-sdk配置sdk环境">2、安装Android SDK，配置SDK环境</h3>
<p>可以直接下载Android Studio，但是如果只是做自动化的话只需要下载Android SDK就行了。此处我们只下载SDK即可。</p>
<p>若本地无软件请去这里下载，下载地址：http://tools.android-studio.org/index.php/sdk/</p>
<figure data-type="image" tabindex="3"><img src="https://liujinyang6.github.io/post-images/1596166208034.png" alt="" loading="lazy"></figure>
<p>下载成功解压后配置Android SDK的环境。</p>
<p>新建<code>ANDROID_HOME</code>，环境变量内容就配置我们SDK的安装目录，此处我是：<code>C:\Program Files (x86)\Android\android-sdk</code>，根据自己的实际（安装）情况决定。</p>
<p>如图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://liujinyang6.github.io/post-images/1596166231740.png" alt="" loading="lazy"></figure>
<p>打开安装好的SDK文件夹，双击SDK Manager，安装Tools下的Android SDK Platform-tools和Android SDK Build-tools，Android SDK Tools可以选择是否更新，建议直接更新。</p>
<p>Tools里面的三个必须勾选，版本无所谓。</p>
<figure data-type="image" tabindex="5"><img src="https://liujinyang6.github.io/post-images/1596166244383.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>注意：<strong>下方的镜像（API），随便选一个版本也可以选择多个版本安装，由于镜像比较大，所以有android真机的可以不下载镜像（切记），没有真机的同学才需要安装下方的api镜像，况且安卓本身的模拟器很难用，很卡，我们一般采用第三方模拟器，比如</strong>逍遥、蓝叠</strong>等来生成安卓模拟器，所以建议不用下载下方任何api</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://liujinyang6.github.io/post-images/1596166252886.png" alt="" loading="lazy"></figure>
<p>下方的extra全部勾选，安装</p>
<figure data-type="image" tabindex="7"><img src="https://liujinyang6.github.io/post-images/1596166260872.png" alt="" loading="lazy"></figure>
<p>将<code>%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\build-tools\28.0.3</code> （注意此处我的是28.0.3，请根据自己下载的实际的版本镜像进行替换，位置在sdk安装目录下的build-tools下）加入环境变量Path中。</p>
<figure data-type="image" tabindex="8"><img src="https://liujinyang6.github.io/post-images/1596166268724.png" alt="" loading="lazy"></figure>
<p>检查Android SDK的相关环境变量是否配置成功，win+r 打开运行对话框，输入cmd打开dos命令行窗口，在命令行窗口中输入<code>adb --version</code>，看到以下提示，说明配置成功，如果提示adb不是内部或外部命令，原因有两个：</p>
<p><strong>1-sdk没有安装tools下的platform-tools；</strong></p>
<p><strong>2-sdk的相关环境变量没有配置正确。</strong></p>
<figure data-type="image" tabindex="9"><img src="https://liujinyang6.github.io/post-images/1596166280177.png" alt="" loading="lazy"></figure>
<h3 id="3-安装nodejs">3、安装Node.js</h3>
<p>本地如果没有软件，请去下载地址：https://nodejs.org/en/</p>
<p>选择大多数人下载的那个就行</p>
<figure data-type="image" tabindex="10"><img src="https://liujinyang6.github.io/post-images/1596166290081.png" alt="" loading="lazy"></figure>
<p>1、下载获取到安装文件后，直接双击安装文件，根据程序的提示，完成nodejs的安装（一直下一步就行，可以将路径进行修改）。</p>
<p>将Node.js的安装路径（也就是node.exe文件所在的目录），此处我安装的是d盘，所以是<code>D:\Program Files\nodejs</code>追加到环境变量Path中。</p>
<figure data-type="image" tabindex="11"><img src="https://liujinyang6.github.io/post-images/1596166302120.png" alt="" loading="lazy"></figure>
<p>检查一下环境是否配置好，在命令行中输入npm</p>
<figure data-type="image" tabindex="12"><img src="https://liujinyang6.github.io/post-images/1596166312443.png" alt="" loading="lazy"></figure>
<h3 id="4-安装net-framework如果电脑上安装了或者安装了更高版本的则不需要此步骤">4、安装.net framework（如果电脑上安装了或者安装了更高版本的则不需要此步骤）</h3>
<p>​    由于Appium是用.net开发的，所以安装之前需要安装.net framework，否则安装过程中会报错，官网下载：http://www.microsoft.com/zh-cn/download/details.aspx?id=30653</p>
<p>​    下载成功后直接点击安装即可。</p>
<h3 id="5-安装appium">5、安装Appium</h3>
<p>​    下载地址：https://bitbucket.org/appium/appium.app/downloads/</p>
<p>​    当前最新版本为 AppiumForWindows_1_4_16_1.zip ，注意这是一个 Windows 版本，如果你的电脑为MAC请下载 appium-1.5.3.dmg 。虽然你已经看到了这些下载包，但我不保证你能下载的下来。</p>
<p>​    我们以 Windows 为例，将下载的 AppiumForWindows.zip 进行解压，点击 appium-installer.exe 进行安装。</p>
<p>​    在Path中配置appium的环境变量，将安装的Appium文件夹所在目录\Appium\node_modules.bin添加进path</p>
<figure data-type="image" tabindex="13"><img src="https://liujinyang6.github.io/post-images/1596166337381.png" alt="" loading="lazy"></figure>
<p>cmd打开命令行窗口，输入appium-doctor ，出现以下提示，All Checks were successful ,说明环境配置成功。</p>
<figure data-type="image" tabindex="14"><img src="https://liujinyang6.github.io/post-images/1596166348943.png" alt="" loading="lazy"></figure>
<h3 id="六-安装appium-python-client这步很重要目的是需要将python与appium关联起来">六、安装appium - python - client（这步很重要，目的是需要将Python与appium关联起来)</h3>
<p>​    首先需要安装Python3.x，进行环境配置</p>
<p>​    cmd打开命令行窗口，输入：pip install Appium-Python-Client，提示成功就可以了，我这边是已经安装过了。</p>
<figure data-type="image" tabindex="15"><img src="https://liujinyang6.github.io/post-images/1596166360731.png" alt="" loading="lazy"></figure>
<p>如果提示以下错误:</p>
<figure data-type="image" tabindex="16"><img src="https://liujinyang6.github.io/post-images/1596166372309.png" alt="" loading="lazy"></figure>
<p>则通过<strong>更换国内安装源</strong>和<strong>设置超时时间</strong>可以解决。</p>
<p>在<code>pip install XXX</code>命令的后面加上<br>
<code>--default-timeout=100 -i https://pypi.tuna.tsinghua.edu.cn/simple</code>即可。<br>
有时候只需更换国内安装源便可解决问题。如下图所示:</p>
<figure data-type="image" tabindex="17"><img src="https://liujinyang6.github.io/post-images/1596166382981.png" alt="" loading="lazy"></figure>
<p>至此，appium环境搭建成功！！！</p>
<hr>
<h2 id="三-启动真机或模拟器准备工作">三、启动真机或模拟器准备工作</h2>
<p>启动目标app前先确定以下条件是否满足：</p>
<h3 id="1appium服务器是否正常运行">1.appium服务器是否正常运行</h3>
<p>双击该软件appium-desktop，启动appium服务器</p>
<figure data-type="image" tabindex="18"><img src="https://liujinyang6.github.io/post-images/1596166393778.png" alt="" loading="lazy"></figure>
<p>启动后：</p>
<figure data-type="image" tabindex="19"><img src="https://liujinyang6.github.io/post-images/1596166403565.png" alt="" loading="lazy"></figure>
<p>点击start Server，启动appium服务器</p>
<figure data-type="image" tabindex="20"><img src="https://liujinyang6.github.io/post-images/1596166414358.png" alt="" loading="lazy"></figure>
<p>看到以上图形，代表服务启动成功。</p>
<h3 id="2手机模拟器是否已连接且能在adb中查看到">2.手机/模拟器是否已连接，且能在adb中查看到</h3>
<p>通过dos窗口输入adb devices查看，下图为模拟器的例子</p>
<figure data-type="image" tabindex="21"><img src="https://liujinyang6.github.io/post-images/1596166427096.png" alt="" loading="lazy"></figure>
<p>adb 命令进行连接模拟器，</p>
<p>命令：<code>adb connect 127.0.0.1:port</code>----（此处的端口由模拟器决定，不同的模拟器默认端口不同），如下图:</p>
<figure data-type="image" tabindex="22"><img src="https://liujinyang6.github.io/post-images/1596166443937.png" alt="" loading="lazy"></figure>
<p>各种模拟器默认端口：</p>
<table>
<thead>
<tr>
<th>夜神安卓模拟器</th>
<th><strong>62001</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>逍遥安卓模拟器</strong></td>
<td><strong>21503</strong></td>
</tr>
<tr>
<td><strong>BlueStacks (蓝叠安卓模拟器)</strong></td>
<td><strong>5555</strong></td>
</tr>
<tr>
<td><strong>雷电安卓模拟器</strong></td>
<td><strong>5555</strong></td>
</tr>
<tr>
<td><strong>天天安卓模拟器</strong></td>
<td><strong>5037</strong></td>
</tr>
<tr>
<td><strong>网易MuMu (安卓模拟器)</strong></td>
<td><strong>7555</strong></td>
</tr>
<tr>
<td><strong>安卓模拟器大师</strong></td>
<td><strong>54001</strong></td>
</tr>
<tr>
<td><strong>Genymotion</strong></td>
<td><strong>5555</strong></td>
</tr>
</tbody>
</table>
<p>如果是安卓真机，需要在设置里面进入关于手机，里面连击版本号，会提示手机已进入开发者模式，在设置中查找开发者选项，开启USB调试，再次通过数据线连接手机即可。</p>
<ul>
<li>注意：模拟器和真机不要同时连接，以免产生影响</li>
</ul>
<h3 id="3被测软件是否已经安装到真机模拟器上">3.被测软件是否已经安装到真机/模拟器上</h3>
<p>将目标apk安装到目标机器上，如果是模拟器，如下图：</p>
<figure data-type="image" tabindex="23"><img src="https://liujinyang6.github.io/post-images/1596166453479.png" alt="" loading="lazy"></figure>
<p>点击此处，找到目标apk，即可安装到模拟器</p>
<p>以上3个条件满足，我们开始编写代码，来启动app</p>
<hr>
<h2 id="四-appium启动">四、appium启动</h2>
<p>此处我们以模拟器上的今日头条的apk为例</p>
<pre><code class="language-python"># 导入appium包
from appium import webdriver
import time

# 设置启动参数
def startUp():
    
    print(&quot;启动中......&quot;)
    
    # 启动参数设置成dict数据格式
    desire_caps = {
        &quot;deviceName&quot;: &quot;127.0.0.1:21503&quot;,
        &quot;platformName&quot;: &quot;Android&quot;,
        &quot;platformVersion&quot;: &quot;5.1.1&quot;,
        &quot;appPackage&quot;: &quot;com.ss.android.article.news&quot;,
        &quot;appActivity&quot;: &quot;com.ss.android.article.news.activity.MainActivity&quot;,
        &quot;noReset&quot;: True,
        &quot;unicodeKeyboard&quot;: True
    }
    
    # 启动app（第一个参数输入appium server的服务器地址，默认端口为4723，第二个参数输入启动参数）
    driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub', desire_caps)
    
    print(&quot;启动完成，等待3秒。&quot;)
    
    time.sleep(3)
    
    # 定位目标元素，进行操作
    
    # 关闭app
    
if __name__ = '__main__':
    
    startUp()
    


</code></pre>
<p><code>&quot;deviceName&quot;</code>: 通过<code>adb devices</code>获取，此处是模拟器所以填写的是ip和port<br>
<code>&quot;platformName&quot;</code>: 被测系统决定是Android还是ios,<br>
<code>&quot;platformVersion&quot;</code>: 通过查看被测系统的设置查看,<br>
<code>&quot;appPackage&quot;</code>: 通过<code>aapt dump badging xxx.apk | findstr package</code>获取,<br>
<code>&quot;appActivity&quot;</code>: 通过<code>aapt dump badging xxx.apk | findstr activity</code>获取,</p>
<p>操作方法：</p>
<p>1、 将目标apk放在一个已知目录下</p>
<p>2、 进入dos环境，进入到该目录下，输入</p>
<p><code>aapt dump badging jinritoutiao.apk |findstr package</code>  ----用来查看package</p>
<p><code>aapt dump badging jinritoutiao.apk |findstr activity</code>  ----用来查看activity</p>
<p>如果是linux或者mac 则把<code>findstr</code>换成<code>grep</code></p>
<p>总结：</p>
<p>​    <code>aapt dump badging D:\XXX.apk</code>:  获取安装包的所有信息</p>
<p><code>adb devices</code>: 查看手机是否连接到电脑，可以看到设备名称</p>
<p>​	其他：</p>
<p>​    <code>adb shell dumpsys activity</code>：查看当前运行的是哪个activity,运行的一些进程等</p>
<p>​    <code>adb shell pm list packages</code>：列出所有的包名。</p>
<p>​    <code>adb shell dumpsys package</code>：列出所有的安装应用的信息</p>
<p>​    <code>adb shell dumpsys package com.android.XXX</code>：查看某个包的具体信息</p>
<p>​    <code>adb logcat | grep ActivityManager</code>：查看当前正在运行的Activity</p>
<p>详细操作：</p>
<p>1、 连接真机或者模拟器（此处以真机为例）</p>
<p>​    连接手机时注意选择手机的开发者模式，cmd打开命令行窗口，输入adb devices获取到设备的deviceName。</p>
<figure data-type="image" tabindex="24"><img src="https://liujinyang6.github.io/post-images/1596166466871.png" alt="" loading="lazy"></figure>
<p>2.获取Activity</p>
<p>​    cmd打开命令行窗口，输入<code>aapt dump badging D:\XXX.apk</code>（xxx指安装包名，D:\是指路径）直接查看需要测试app安装包的具体信息。</p>
<figure data-type="image" tabindex="25"><img src="https://liujinyang6.github.io/post-images/1596166473014.png" alt="" loading="lazy"></figure>
<p>标记的就是包名，继续往下拖拽，可以找到activity的信息。</p>
<figure data-type="image" tabindex="26"><img src="https://liujinyang6.github.io/post-images/1596166479616.png" alt="" loading="lazy"></figure>
<p>这里的红圈就可以看到activity的信息。这两个值，在appium脚本中都需要提前获取到，所以需要提前介绍这个获取方法。如果你觉得在cmd里面不好看，你可以把cmd信息导出到一个txt文件，例如 <code>aapt dump badging shoujibaidu.apk &gt; 123.txt</code> 回车后，会在桌面生成一个123.txt文件，你可以打开，通过查询找到这些信息。通过上面的方法，只要我们有android SDK环境，那么我们就可以获取到任意一个包的包名和Activity信息。</p>
<p>填好一下参数，参数说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>能力</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
<th style="text-align:center"><strong>值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">appPackage</td>
<td style="text-align:center">App的包名，通过aapt dumpsys badging xxx.apk获取</td>
<td style="text-align:center">例如：'appPackage':  'com.jyibb.shell_customer',</td>
</tr>
<tr>
<td style="text-align:center">platformName</td>
<td style="text-align:center">使用哪个移动操作系统平台</td>
<td style="text-align:center">例如：'platformName': 'Android'</td>
</tr>
<tr>
<td style="text-align:center">platformVersion</td>
<td style="text-align:center">移动操作系统版本</td>
<td style="text-align:center">例如：'platformVersion': '5.1'</td>
</tr>
<tr>
<td style="text-align:center">deviceName</td>
<td style="text-align:center">使用的移动设备或模拟器的名称，通过adb devices获取</td>
<td style="text-align:center">例如：'deviceName':'8TB6V4ZPZ54LPJ5P'</td>
</tr>
<tr>
<td style="text-align:center">app</td>
<td style="text-align:center">如果为第一次启动则需要通过该参数指定app安装包的位置，一般为绝对路径</td>
<td style="text-align:center">例如：'app': ‘D:\shell_customer-debug.apk'</td>
</tr>
<tr>
<td style="text-align:center">newCommandTimeout</td>
<td style="text-align:center">在假定客户端退出并结束会话之前，Appium将等待来自客户端的新命令（以秒为单位）</td>
<td style="text-align:center">例如 60</td>
</tr>
<tr>
<td style="text-align:center">appActivity</td>
<td style="text-align:center">通过aapt dumpsys badging xxx.apk获取</td>
<td style="text-align:center">例如   'appActivity':  'com.jyibb.module_launch_customer.SplashActivity',</td>
</tr>
<tr>
<td style="text-align:center">udid</td>
<td style="text-align:center">连接的物理设备的唯一设备标识符，此参数为ios特有参数</td>
<td style="text-align:center">例如 ：'udid':'1ae203187fc012g'</td>
</tr>
<tr>
<td style="text-align:center">noReset</td>
<td style="text-align:center">在此会话之前不要重置应用程序状态。</td>
<td style="text-align:center">true， false</td>
</tr>
<tr>
<td style="text-align:center">fullReset</td>
<td style="text-align:center">执行完整的重置。</td>
<td style="text-align:center">true， false</td>
</tr>
<tr>
<td style="text-align:center">unicodeKeyboard</td>
<td style="text-align:center">解决输入中文的问题，否则不能用sendkeys输入中文</td>
<td style="text-align:center">例如，   ‘unicodeKeyboard':'True'</td>
</tr>
<tr>
<td style="text-align:center">resetKeyboard</td>
<td style="text-align:center">将键盘隐藏起来，默认true</td>
<td style="text-align:center">true， false</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五-appium元素定位">五、 appium元素定位</h2>
<h3 id="1-常用识别元素的工具">1、常用识别元素的工具</h3>
<ol>
<li>
<p><code>uiautomator</code>：Android SDK自带的一个工具，在sdk的tools目录下（一定关闭appium-desktop的自带的定位工具后打开，否则连接不上模拟器/真机 ）</p>
<p>找到sdk下的tools里面的uiautomatorviewer.bat</p>
</li>
</ol>
<p>​		<img src="https://liujinyang6.github.io/post-images/1596166491903.png" alt="" loading="lazy"></p>
<p>​		双击打开后界面是：</p>
<p>​		<img src="https://liujinyang6.github.io/post-images/1596166500251.png" alt="" loading="lazy"></p>
<p>​		点击后，可以连上模拟器和真机</p>
<p>​		<img src="https://liujinyang6.github.io/post-images/1596166510869.png" alt="" loading="lazy"></p>
<p>​		以头条app为例</p>
<p>​		<img src="https://liujinyang6.github.io/post-images/1596166520322.png" alt="" loading="lazy"></p>
<ol start="2">
<li>
<p>appium-desktop优先使用desktop</p>
<p>启动appium-desktop，点击服务器右上角的查找按钮，界面如下</p>
</li>
</ol>
<p>​	<img src="https://liujinyang6.github.io/post-images/1596166531803.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="27"><img src="https://liujinyang6.github.io/post-images/1596166542773.png" alt="" loading="lazy"></figure>
<p>点击启动后：</p>
<figure data-type="image" tabindex="28"><img src="https://liujinyang6.github.io/post-images/1596166551141.png" alt="" loading="lazy"></figure>
<p>使用介绍：</p>
<figure data-type="image" tabindex="29"><img src="https://liujinyang6.github.io/post-images/1596166560283.png" alt="" loading="lazy"></figure>
<p>使用方法：</p>
<figure data-type="image" tabindex="30"><img src="https://liujinyang6.github.io/post-images/1596166569551.png" alt="" loading="lazy"></figure>
<ol start="3">
<li><code>monitor</code>：Android SDK自带的一个工具，在tools目录下，此工具主要用来监控Android手机的运行情况，比如线程、堆内存，日志输出、等等。</li>
</ol>
<h3 id="2元素定位">2.元素定位</h3>
<h4 id="1格式find_element_by_定位方式value">1.格式：find_element_by_定位方式(value)</h4>
<h5 id="通过id定位">通过id定位</h5>
<pre><code class="language-python"># 取resource-id的值
driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/azo&quot;)

# 也可以直接用id后面的内容
driver.find_element_by_id(&quot;azo&quot;)

</code></pre>
<h5 id="通过class_name定位">通过class_name定位</h5>
<pre><code class="language-python"># 取class的内容
driver.find_element_by_class_name(&quot;android.widget.RelativeLayout&quot;)

</code></pre>
<h5 id="通过xpath定位">通过xpath定位</h5>
<pre><code class="language-python"># 取xpath得内容
driver.find_element_by_xpath(&quot;//android.widget.LinearLayout[1]/android.widget.XXX&quot;)

</code></pre>
<h5 id="通过text定位">通过text定位</h5>
<pre><code class="language-python"># 需要使用uiautomator的定位方式，使用text的内容
driver.find_elements_by_android_uiautomator(&quot;new UiSelector().text(\&quot;+关注\&quot;)&quot;)

</code></pre>
<p>使用这里需要注意一下，通过text定位的结果是个list，不能直接click。所以如果要点击需要取数组的值，比如下面是点击找到的第一个元素</p>
<p><code>driver.find_elements_by_android_uiautomator(&quot;new UiSelector().text(\&quot;+关注\&quot;)&quot;)[0].click()</code></p>
<h5 id="通过css_selector定位webview">通过css_selector定位(webview)</h5>
<pre><code class="language-python"># 只适用于webview的html页面，继承自webdriver，与pc版本的UI测试一致
driver.find_element_by_css_selector()

</code></pre>
<h5 id="通过link_text定位webview">通过link_text定位(webview)</h5>
<pre><code class="language-python"># 只适用于webview容器中的html页面，继承自webdriver，与pc版本的UI测试一致
driver.find_element_by_link_text()

</code></pre>
<h5 id="通过name定位webview">通过name定位(webview)</h5>
<pre><code class="language-python"># webview容器中的html页面可以用name定位，native并没有name属性
driver.find_element_by_name()

</code></pre>
<h4 id="2定位元素的另一种写法find_elementbyvalue">2.定位元素的另一种写法：find_element(by,value)</h4>
<p><code>find_element_by_方式(value)</code>实际调用的都是<code>find_element(by,value)</code></p>
<p>需要导入这个包：<code>from selenium.webdriver.common.by import By</code></p>
<pre><code class="language-python"># 例如：定位id为ag2的元素
# 方式一：
driver.find_element_by_id(&quot;ag2”)
# 方式二：
driver.find_element(By.ID,&quot;ag2&quot;)
 

# 这个操作的好处是可以直接把操作的by和value放到一个元组里，然后调用通用方法来传参获得元素结果
cateid=(By.ID,&quot;ag2&quot;)

driver.find_element(*cateid).click()

</code></pre>
<p><strong>by</strong>的操作可以是</p>
<p><code>By.ID</code>  相当于by_id</p>
<p><code>By.CLASS_NAME</code> 相当于by_class_name</p>
<p><code>By.XPATH</code>  相当于by_xpath</p>
<p><code>By.NAME</code>  相当于by_name</p>
<p><code>By.TAG_NAME</code>  相当于by_tag_name</p>
<p><code>By.CSS_SELECTOR</code> 相当于by_css_selector</p>
<p><code>By.LINK_TEXT</code> 相当于by_link_text</p>
<p><code>By.android_uiautomator</code> 相当于by_android_uiautomator()</p>
<p>查看具体写法可以关注https://www.cnblogs.com/cnkemi/p/9185253.html</p>
<h4 id="3find_elements_by_定位方式value返回元素数组">3.find_elements_by_定位方式(value)返回元素数组</h4>
<p>用法与find_element_by_方式(value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果</p>
<p>例如：通过class_name定位到多个元素，我想点击第一个元素</p>
<p><code>driver.find_elements_by_class_name(&quot;android.widget.RelativeLayout”)[0].click()</code></p>
<h4 id="4返回元素数组的另一种写法find_elementsbyvalue">4.返回元素数组的另一种写法：find_elements(by,value)</h4>
<p>用法与find_element(by,value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果</p>
<p>例如：通过class_name定位到多个元素，我想点击第一个元素</p>
<p><code>driver.find_elements(By.CLASS_NAME,&quot;android.widget.RelativeLayout&quot;)[0].click()</code></p>
<h4 id="5通过元素定位元素">5.通过元素定位元素</h4>
<p>可以先找到某个元素，然后再进一步定位元素</p>
<p><code>find_element_by_class_xpath(“xxx”).find_element_by_name(“yyy&quot;)</code></p>
<h4 id="6xpath定位详解">6.Xpath定位详解</h4>
<p><strong>手工编写：</strong></p>
<ol>
<li>纯标签路径：position</li>
</ol>
<p>绝对路径：<code>/html/body/div/div[3]/div[2]/form/input</code></p>
<p>相对路径：<code>//div[2]/form/input</code></p>
<ol start="2">
<li>标签和属性结合:attribute</li>
</ol>
<p>语法：<code>//标签名[@属性=属性值]</code></p>
<p>例如：</p>
<p><code>//input[@id='word']</code></p>
<p><code>//form/input[@id='word']</code>----标签可以有多个，也可以只有一个</p>
<p><code>//div[@class='hotwords']/a[1]</code>---也可利用上层标签的属性进行定位</p>
<p>示例：</p>
<pre><code class="language-python">driver = webdriver.Firefox()

driver.implicitly_wait(5)

driver.maximize_window()

driver.get('http://127.0.0.1:8888/iwebshop/')

driver.find_element_by_xpath(&quot;//div[@class='hotwords']/a[1]&quot;).click()

time.sleep(5)

driver.quit()

</code></pre>
<h4 id="7css定位详解">7.CSS定位详解</h4>
<p>层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p>
<p>CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。CSS能够根据不同使用者的理解能力，简化或者优化写法，针对各类人群，有较强的易读性。</p>
<p><strong>使用Firebug复制：</strong></p>
<p>右击目标对象，使用Firebug查看元素，在其高亮区域右击选择复制css路径</p>
<p><strong>手工编写</strong></p>
<p>标签和属性组合：<code>标签名[属性名=属性值]</code></p>
<p>----标签名可以多个，多个时需要用空格隔开：form input.text</p>
<p>----属性可以随意：input[type='text']&quot;</p>
<p>例子：Input[class=’xxx’]</p>
<p>注意：class/id除了可以采用<code>[属性=属性值]</code>的写法，还可以用专用写法</p>
<p>通过<code>class</code>编写：<code>标签名.class的属性值</code></p>
<p>通过<code>id</code>编写：<code>标签名#id的值</code></p>
<p>组合 ：<code>标签名#id值.class值</code></p>
<p>示例：</p>
<pre><code class="language-python">driver = webdriver.Firefox()

driver.implicitly_wait(5)

driver.maximize_window()

driver.get('http://127.0.0.1:8888/iwebshop/')

driver.find_element_by_css_selector(&quot;div.brand div.cont ul li a img&quot;).click()

time.sleep(8)

driver.quit()
</code></pre>
<hr>
<h3 id="六-元素操作">六、元素操作</h3>
<p>找到元素后可以对元素进行的操作，例如上面讲的进一步定位元素</p>
<h4 id="1click">1.click()</h4>
<p>//点击操作</p>
<p>也可以用tap实现点击操作</p>
<p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ae8&quot;).click()</code></p>
<h4 id="2clear">2.clear()</h4>
<p>//清空输入框内容</p>
<p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ij&quot;).clear()</code></p>
<h4 id="3send_keysxx">3.send_keys(xx)</h4>
<p>//输入框内输入内容</p>
<p><code>driver.find_element_by_id(&quot;com.wuba.zhuanzhuan:id/ij&quot;).send_keys(&quot;test content&quot;)</code></p>
<h4 id="4text">4.text</h4>
<p>//获得元素的text内容</p>
<p><code>print(driver.find_element_by_xpath(&quot; //android.widget.LinearLayout[1]//xxx&quot;).text)</code></p>
<hr>
<h3 id="七-触摸操作">七、触摸操作</h3>
<h4 id="1drivertap坐标持续点击时间">1.driver.tap([坐标]，持续点击时间)</h4>
<p>除了定位到元素的点击外，也可以通过tab实现坐标的点击</p>
<p><code>driver.tap()</code></p>
<h4 id="2touchactiondriver">2.TouchAction(driver)</h4>
<p>TouchAction对象包含（tap）、press（短按）、move_to（滑动到某个坐标）等方法</p>
<p>通过TouchAction对象，添加tap、move_to等操作，然后perform()执行，可以实现解锁屏幕等功能</p>
<p>规范中的可用事件有：</p>
<p><code>短按 (press)</code><br>
<code>释放 (release)</code><br>
<code>移动到 (moveTo)</code><br>
<code>点击 (tap)</code><br>
<code>等待 (wait)</code><br>
<code>长按 (longPress)</code><br>
<code>取消 (cancel)</code><br>
<code>执行 (perform)</code></p>
<p>示例：</p>
<p>一个多次滑屏的例子：</p>
<pre><code class="language-python">action = TouchAction(driver)

action.press(x=220,y=700).move_to(x=840, y=700).move_to(x=220, y=1530).move_to(x=840, y=1530).release().perform()

# 可以通过wait()等待操作
action.press(x=220,y=700).move_to(x=840, y=700).wait(1).perform()
</code></pre>
<h4 id="3multiaction-多点触控">3.MultiAction()  多点触控</h4>
<p>通过<code>MultiAction().add()</code>添加多个<code>TouchAction</code>操作，最后调用<code>perform()</code>一起执行这些操作</p>
<pre><code class="language-python">action0 = TouchAction().tap(el)


action1 = TouchAction().tap(el)


MultiAction().add(action0).add(action1).perform()
</code></pre>
<h4 id="4driverswipex1-y1-x2-y2duration">4.driver.swipe(x1, y1, x2, y2,duration)</h4>
<p>从<code>坐标(x1,x2)</code>滑动到坐标<code>(x2,y2)</code>，<code>duration</code>非必填项，滑动时间（滑动的坐标不能超过屏幕的宽高）</p>
<p>可以通过<code>driver.get_window_size()</code>命令获得窗口高和宽，结果为{'width': 1080, 'height': 1776}</p>
<p>一个向上下左右滑动屏幕的例子如下：</p>
<pre><code class="language-python"># 获得屏幕大小宽和高
def getSize(self):

	x = self.driver.get_window_size()['width']
	y = self.driver.get_window_size()['height']
	
	return (x,y)

# 向上滑动屏幕
def swipeUp(self, t=1000):
	
    l = getSize()
    x1 = int(l[0] * 0.5)
    y1 = int(l[1] * 0.25)
    y2 = int(l[1] * 0.75)
    
    self.driver.swipe(x1, y1, x1, y2, t)
    

# 向下滑动屏幕
def swipeDown(self, t=1000):
    
    l = getSize()
    x1 = int(l[0] * 0.5)
    y1 = int(l[1] * 0.75)
    y2 = int(l[1] * 0.25)
    
    self.driver.swipe(x1, y1, x1, y2, t)
    
    
# 向左滑动屏幕
def swipeLeft(self, t=1000):
    
    l = getSize()
    y1 = int(l[1] * 0.5)
    x1 = int(l[0] * 0.25)
    x2 = int(l[0] * 0.75)
    
    self.driver.swipe(x1, y1, x2, y1, t)
    

    
# 向右滑动屏幕
def swipeRight(self, t=1000):
    
    l = getSize()
    y1 = int(l[1] * 0.5)
    x1 = int(l[0] * 0.75)
    x2 = int(l[0] * 0.25)
    
    self.driver.swipe(x1, y1, x2, y1, t)
    
  
# 调用向下滑动的方法
swipeDown(driver)
</code></pre>
<hr>
<h3 id="八-系统按键事件">八、系统按键事件</h3>
<h4 id="press_keycodeandroidkeycode">press_keycode(AndroidKeyCode)</h4>
<p>例如：点击home键，home键的KeyCode是3</p>
<p><code>driver.press_keycode(3)</code></p>
<table>
<thead>
<tr>
<th>键名</th>
<th>描述</th>
<th>键值</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEYCODE_CALL</td>
<td>拨号键</td>
<td>5</td>
</tr>
<tr>
<td>KEYCODE_ENDCALL</td>
<td>挂机键</td>
<td>6</td>
</tr>
<tr>
<td>KEYCODE_HOME</td>
<td>按键Home</td>
<td>3</td>
</tr>
<tr>
<td>KEYCODE_MENU</td>
<td>菜单键</td>
<td>82</td>
</tr>
<tr>
<td>KEYCODE_BACK</td>
<td>返回键</td>
<td>4</td>
</tr>
<tr>
<td>KEYCODE_SEARCH</td>
<td>搜索键</td>
<td>84</td>
</tr>
<tr>
<td>KEYCODE_CAMERA</td>
<td>拍照键</td>
<td>27</td>
</tr>
<tr>
<td>KEYCODE_FOCUS</td>
<td>拍照对焦键</td>
<td>80</td>
</tr>
<tr>
<td>KEYCODE_POWER</td>
<td>电源键</td>
<td>26</td>
</tr>
<tr>
<td>KEYCODE_NOTIFICATION</td>
<td>通知键</td>
<td>83</td>
</tr>
<tr>
<td>KEYCODE_MUTE</td>
<td>话筒静音键</td>
<td>91</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_MUTE</td>
<td>扬声器静音键</td>
<td>164</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_UP</td>
<td>音量增加键</td>
<td>24</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_DOWN</td>
<td>音量减小键</td>
<td>25</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="九-driver的一些其他操作">九、driver的一些其他操作</h3>
<h4 id="1reset">1.reset()</h4>
<ul>
<li>重置app：这时候driver会重置，相当于卸载重装应用。所以本地缓存会失效</li>
</ul>
<p><code>driver.reset()</code></p>
<h4 id="2scroll起始元素结束元素">2.scroll(起始元素，结束元素)</h4>
<ul>
<li>滑动屏幕：从起始元素滑动到结束元素</li>
</ul>
<p><code>driver.scroll(origin_el,destination_el)</code></p>
<h4 id="3driverpage_source">3.driver.page_source</h4>
<ul>
<li>获取当前页面内的所有元素</li>
</ul>
<p>这可以用来判断元素是否存在，例如：<code>assert &quot;发布成功&quot; in driver.page_source</code></p>
<h4 id="4driveris_app_installedpackage_name">4.driver.is_app_installed(package_name)</h4>
<ul>
<li>检查app安装情况（返回true或false）</li>
</ul>
<p><code>driver.is_app_installed(package_name)</code></p>
<h4 id="5driverinstall_appxxxxapk">5.driver.install_app(&quot;x:/xxx.apk&quot;)</h4>
<ul>
<li>安装app</li>
</ul>
<p><code>driver.install_app(&quot;x:/xxx.apk&quot;)</code></p>
<h4 id="6driverremove_apppackage_name">6.driver.remove_app(package_name)</h4>
<ul>
<li>卸载app</li>
</ul>
<p><code>driver.remove_app(package_name)</code></p>
<h4 id="7driveropen_notifications">7.driver.open_notifications()</h4>
<ul>
<li>打开通知栏</li>
</ul>
<p><code>driver.open_notifications()</code></p>
<h4 id="8driverclose_app">8.driver.close_app()</h4>
<ul>
<li>关闭app</li>
</ul>
<p><code>driver.close_app()</code></p>
<h4 id="9driverlaunch_app">9.driver.launch_app()</h4>
<ul>
<li>启动app</li>
</ul>
<p><code>driver.launch_app()</code></p>
<h4 id="10drivershake">10.driver.shake</h4>
<ul>
<li>模拟摇晃设备</li>
</ul>
<p><code>driver.shake</code></p>
<h4 id="11driverresetapp">11.driver.resetApp()</h4>
<ul>
<li>重置应用</li>
</ul>
<p><code>driver.resetApp()</code></p>
<h4 id="12driverfind_element_by_idactivity">12.driver.find_element_by_id(activity)</h4>
<ul>
<li>检查是否存在某个activity(未找到则返回异常）</li>
</ul>
<p><code>driver.find_element_by_id(activity)</code></p>
<h4 id="13selfdrivercurrent_activity">13.self.driver.current_activity</h4>
<ul>
<li>获取当前的activity</li>
</ul>
<pre><code class="language-python">activity = self.driver.current_activity 

print(u&quot;当前的activity是:&quot;, activity)
</code></pre>
<h4 id="14driverwait_activityactivity-x-y">14.driver.wait_activity(activity, x, y)</h4>
<ul>
<li>等待activity启动直到x秒超时，每隔y秒扫描一次</li>
</ul>
<p><code>driver.wait_activity(activity, x, y)</code></p>
<h4 id="15driverbackground_appx">15.driver.background_app(x)</h4>
<ul>
<li>
<p>将app置于后台运行x s</p>
</li>
<li>
<p>注意：测试发现置于后台数秒后变为前台时，将是重新启动app，进入首页，而不是切入后台时的界面</p>
</li>
</ul>
<p><code>driver.background_app(x)</code></p>
<h4 id="16driveravailable_ime_engines">16.driver.available_ime_engines</h4>
<ul>
<li>打印可用的输入法</li>
</ul>
<pre><code class="language-python">IME_LISE = driver.available_ime_engines

print(IME_LISE)
</code></pre>
<h4 id="17driveractivate_ime_engineime_lise-1">17.driver.activate_ime_engine(IME_LISE[-1])</h4>
<ul>
<li>激活安卓设备中的指定输入法(设备可用输入法可以从“available_ime_engines”获取)&quot;</li>
</ul>
<p><code>driver.activate_ime_engine(IME_LISE[-1])</code></p>
<h4 id="18driveris_ime_active">18.driver.is_ime_active()</h4>
<ul>
<li>检查设备是否有输入法服务活动,返回True/False</li>
</ul>
<p><code>driver.is_ime_active()</code></p>
<h4 id="19driverhide_keyboard">19.driver.hide_keyboard()</h4>
<ul>
<li>退出键盘</li>
</ul>
<p><code>driver.hide_keyboard()</code></p>
<hr>
<h3 id="十-自动化测试用例的实现">十、自动化测试用例的实现</h3>
<p>以今日头条发微头条为例：</p>
<p>前提：启动头条app，且是登录状态</p>
<ol>
<li>
<p>打开首页，点击发表按钮</p>
</li>
<li>
<p>点击微头条，输入内容</p>
</li>
<li>
<p>点击发布</p>
</li>
<li>
<p>检查是否发表成功（数据库/页面）</p>
</li>
</ol>
<p>自动化：</p>
<ol>
<li>
<p>定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入）</p>
</li>
<li>
<p>定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入）</p>
</li>
<li>
<p>定位目标元素（坐标，元素属性），操作目标元素（点击，滑动，输入）</p>
</li>
<li>
<p>断言（接口状态码，数据库字段，app页面）</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DDT框架]]></title>
        <id>https://liujinyang6.github.io/post/ddt-kuang-jia/</id>
        <link href="https://liujinyang6.github.io/post/ddt-kuang-jia/">
        </link>
        <updated>2020-03-20T06:18:35.000Z</updated>
        <content type="html"><![CDATA[<p>​		<br>
​		<strong>数据驱动</strong>的单元测试是为数据源中的每一行重复运行的一种单元测试。<strong>数据驱动</strong>的单元测试的常用情况是使用多个输入值测试 API。不是编写调用 API 的多个单元测试（每个单元测试均具有一组新的输入），也不是在单元测试中创建一个数组并使用循环代码，而是可以编写执行 API 的单个单元测试方法。然后可以从数据库表的行中进行数据检索以便传递给该测试方法的连续调用。可以使用此技术测试由不同用户（每个用户具有不同角色）使用的应用程序。对于每个用户，数据源中的一行将根据角色指示预期响应。然后，该测试将通过针对每个用户运行功能，对该应用程序进行测试，并验证产生的响应是否与预期响应一致。</p>
<p>​		在测试工作中，针对某一API接口，或者某一个用户界面的输入框，需要设计大量相关的用例，每一个用例包含实际输入的各种可能的数据。通常的做法是，将测试数据存放到一个数据文件里，然后从数据文件读取，在脚本中循环输入测试数据，并对结果进行验证。</p>
<p>​		<code>ddt</code>是结合<code>unittest</code>框架来工作的，所以要先具备<code>unittest</code>框架的知识。</p>
<hr>
<h2 id="使用步骤">使用步骤</h2>
<p>1.导入ddt包</p>
<p>2.用装饰器装饰@ddt</p>
<p>3.传入参数，执行</p>
<hr>
<h2 id="传参示例">传参示例</h2>
<h3 id="传参方式一单个传参">传参方式一：单个传参</h3>
<pre><code class="language-python"># 单个传参

import unittest
from ddt import ddt,data,unpack


@ddt
class MyTestCase1(unittest.TestCase):
    
    # 2,3,4会分别按照执行次数传入，比如第一次执行方法传入2，第二次执行方法传入3,第三次......
    @data(2, 3, 4)
    def test_normal(self, value):
        
        print(value)
        
        self.assertEqual(value, 2)

        
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
<hr>
<h3 id="传参方式二元组-列表-字典传参">传参方式二：元组、列表、字典传参</h3>
<pre><code class="language-python"># 元组、列表、字典传参

import unittest
from ddt import ddt,data,unpack


@ddt
class MyTestCase2(unittest.TestCase):
    
    # 会依次按照执行次数传入，比如第一次执行该方法传入（1，2），第二次传入（2，3）
    @data((1, 2), (2, 3))
    @unpack  # 只有需要进行分发参数的时候才需要添加。1分发给value1，2分发给value2
    def test_tuple(self, value1, value2):
        
        print(&quot;tuple:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
     
    @data([1, 2], [2, 3])
    @unpack
    def test_list(self, value1, value2):
        
        print(&quot;list:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
    
    @data({'value1':1, 'value2':2}, {'value1':2, 'value2':3})
    @unpack   # 入参参数名必须和字典key值一致，否则会报错
    def test_dict(self, value1, value2):
        
        print(&quot;dictionary:&quot;,value1, value2)
        
        self.assertEqual(value2, value1+1)
        
     
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
<hr>
<h3 id="传参方式三json文件传参">传参方式三：json文件传参</h3>
<pre><code class="language-python"># 传入json

import unittest
from ddt import ddt,data,unpack,file_data


@ddt
class MyTestCase3(unittest.TestCase):
    
    @file_data('E:\\test.json')
    def test_file(self, value):
        
        print(&quot;json file:&quot;,value)
        
 
if __name__ == '__main__':
    
    unittest.main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unittest教程]]></title>
        <id>https://liujinyang6.github.io/post/unittest-jiao-cheng/</id>
        <link href="https://liujinyang6.github.io/post/unittest-jiao-cheng/">
        </link>
        <updated>2020-03-16T06:33:33.000Z</updated>
        <content type="html"><![CDATA[<p>Python中有一个自带的单元测试框架是<code>unittest</code>模块，用它来做单元测试，它里面封装好了一些校验返回的结果方法和一些用例执行前的初始化操作。在说unittest之前，先说几个概念：</p>
<p><code>TestCase</code> 也就是测试用例</p>
<p><code>TestSuite</code> 多个测试用例集合在一起，就是TestSuite</p>
<p><code>TestLoader</code>是用来加载TestCase到TestSuite中的</p>
<p><code>TestRunner</code>是来执行测试用例的,测试的结果会保存到TestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息</p>
<p>下面我们分别来解释这四个概念的意思，先来看一张unittest的静态类图。</p>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592375687634.png" alt="" loading="lazy"></figure>
<p>一个<code>TestCase</code>的实例就是一个测试用例。什么是测试用例呢？就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)。单元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证。</p>
<p>而多个测试用例集合在一起，就是<code>TestSuite</code>，而且TestSuite也可以嵌套TestSuite。</p>
<p><code>TestLoader</code>是用来加载TestCase到TestSuite中的，其中有几个loadTestsFrom__()方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例。</p>
<p><code>TextTestRunner</code>是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法。</p>
<p>测试的结果会保存到TextTestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息。</p>
<p>一个class继承了unittest.TestCase，便是一个测试用例，但如果其中有多个以 test 开头的方法，那么每有一个这样的方法，在load的时候便会生成一个TestCase实例，如：一个class中有四个test_xxx方法，最后在load到suite中时也有四个测试用例。</p>
<hr>
<p>在每一个测试用例中可以重写 以下函数 :</p>
<p><code>setUp()</code>该测试用例执行前的设置工作、</p>
<p><code>tearDown()</code>该测试用例执行后的清理工作、</p>
<p><code>setUpClass()</code>所有测试用例前的设置工作、</p>
<p><code>tearDownClass()</code>所有测试用例执行后的清洗工作</p>
<hr>
<p>在每一个测试用例中可以通过<code>skip</code>，<code>skipIf</code>，<code>skipUnless</code>装饰器跳过某个测试函数，或者用TestCase.skipTest方法跳过测试函数。</p>
<pre><code class="language-python">@unittest.skip()

@unittest.skipIf()

@unittest.skipUnless()
</code></pre>
<hr>
<p>到这里unittest的整个流程就清楚了：</p>
<p>写好<code>TestCase</code>，然后由<code>TestLoader</code>加载<code>TestCase</code>到<code>TestSuite</code>，然后由<code>TextTestRunner</code>来运行<code>TestSuite</code>，运行的结果保存在<code>TextTestResult</code>中。</p>
<p>我们通过命令行或者<code>unittest.main()</code>执行时，main会自动调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。</p>
<p>加个说明：</p>
<p>1、<code>TestLoader</code>加载<code>TestCase</code>到<code>TestSuite</code>可以通过<code>TestSuite</code>实例对象的<code>addTest()</code>和<code>addTests()</code>方法向suite中添加case或suite</p>
<p>2、在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）。</p>
<p>3、在进行测试时可以传递verbosity参数，用以控制执行结果的输出，0 是简单报告、1 是一般报告、2 是详细报告。</p>
<hr>
<p><strong>被测方法</strong>：</p>
<p>这里我们随意写几个业务函数，表示我们将要进行测试的功能函数。将功能函数文件存储成myfun.py</p>
<pre><code class="language-python"># 被测函数示例
# 保存为mufun.py


def add(a, b):
    
    return a + b


def minus(a, b):
    
    return a - b


def multi(a, b):
    
    return a * b


def divide(a, b):
    
    return a / b
</code></pre>
<p><strong>TestCase测试用例</strong>:</p>
<p>我们通过测试用例用代码来实现每一个测试的详细过程和针对测试目标要测试的内容。同目录下创建test_myfun.py</p>
<pre><code class="language-python"># 测试用例示例


class TestMyFun(unittest.TestCase):
    
    # TestCase基类方法，所有case执行之前自动执行
    @classmethod
    def setUpClass(cls):
        
        print(&quot;这里是所有测试用例前的准备工作&quot;)
        
    
    # TestCase基类方法，所有case执行之后自动执行
    @classmethod
    def tearDownClass(cls):
        
        print(&quot;这里是所有测试用例后的清理工作&quot;)
        
    
    # TestCase基类方法，每次执行case前自动执行
    def setUp(self):
        
        print(&quot;这里是一个测试用例前的准备工作&quot;)
        
    
    # TestCase基类方法，每次执行case后自动执行
    def tearDown(self):
        
        print(&quot;这里是一个测试用例后的清理工作&quot;)
        
        
    @unittest.skip(&quot;我想临时跳过这个测试用例&quot;)
    def test_add(self):                   # 测试add()函数
        
        self.assertEqual(3, add(1, 2))
		
        self.assertNotEqual(3, add(2, 2))
    
    
    def test_minus(self):                 # 测试minus()函数
        
        self.skipTest(&quot;跳过这个测试用例&quot;)
        
        self.assertEqual(1, minus(3, 2))
        
     
     def test_multi(self):                # 测试multi()函数
            
         self.assertEqual(6, multi(2, 3))  
     
    
     def test_divide(self):               # 测试divide()函数
            
         self.assertEqual(2, divide(6, 3))
        
         self.assertEqual(2.5, divide(5, 2))
 

if __name__ == &quot;__main__&quot;:
    
    unittest.main(verbosity=2)
    
    
</code></pre>
<ul>
<li>注意：</li>
</ul>
<p>skip装饰器一共有三个 <code>unittest.skip(reason)</code>、<code>unittest.skipIf(condition,reason)</code>、<code>unittest.skipUnless(condition,reason)</code>，其中<strong>skip</strong>是无条件跳过，<strong>skipIf</strong>是当condition为True时跳过，<strong>skipUnless</strong>是当condition为False时跳过。</p>
<p>每个测试方法<strong>必须</strong>以 <strong>test</strong> 开头，否则是不被unittest识别的。其实每一个test开头的方法都会加载为独立的测试用例。</p>
<p>在unittest.main()中加 <strong>verbosity</strong> 参数可以控制输出的错误报告的详细程度，默认是 1；如果设为 0，则不输出每一用例的执行结果；如果参数为2则表示输出详细结果。</p>
<hr>
<h3 id="testsuite测试套件">TestSuite测试套件</h3>
<p><code>TestSuite</code>用来控制多个测试用例和多个测试文件之间的测试顺序。（这里的示例中的几个测试方法并没有一定关系，但之后你写的用例可能会有先后关系，需要先执行方法A，再执行方法B），我们添加到TestSuite中的case是会按照添加的顺序执行的。</p>
<h4 id="一-创建测试套件">一、创建测试套件</h4>
<p>语法：1.<strong>实例化</strong>、2.调用 <code>addTest()</code>方法</p>
<pre><code class="language-python"># 1.实例化Testsuite类
# 注：TestSuite()主要用来创建测试套件集合
suite = unittest.TestSuite()           

# 2.调用addTest()添加测试方法
# 添加语法：suite.addTest(文件名.类名(‘类中的方法名’))
suite.addTest(TestCount('test_add'))  

# 调用TestSuite类中的addTest：suite.addTest(类名(‘类中的方法名’))
# 执行顺序是按照添加的顺序执行，先添加的先执行

</code></pre>
<ul>
<li>注：test_add是unittest脚本中的被测方法，如果是添加被导入模块中的方法，则需要指定哪个文件名。</li>
<li>suite.addTest(文件名.类名(‘类中的方法名’))</li>
</ul>
<h4 id="二-运行测试套件texttestrunner">二、 运行测试套件TextTestRunner()</h4>
<p>语法：1.<strong>实例化</strong>、 2.调用<code>run()</code>方法</p>
<pre><code class="language-python"># 1.实例化TextTestRunner类
runner = unittest.TextTestRunner()    

# 2.调用Testsuite类中的addTest方法
runner.run(suite)             

</code></pre>
<ul>
<li>注：<strong>TextTestRunner()<strong>主要用来运行</strong>测试套件</strong></li>
</ul>
<hr>
<ul>
<li>
<p><strong>坑</strong>：<a href="https://www.cnblogs.com/kaerxifa/p/11046156.html">使用Unittest做单元测试，addTest（）单个case的时候却执行全部的case</a></p>
<p>首先造成这个结果的原因是pycharm配置问题</p>
</li>
</ul>
<p>测试代码：</p>
<pre><code class="language-python">import unittest


class Testadd(unittest.TestCase):

    def setUp(self):
        self.a = 20
        self.b = 10

        
    def test_add(self):
        result = self.a + self.b
        self.assertEqual(result,30)
    
    
    def test_sub(self):
        result = self.a -self.b
        self.assertEqual(result,10)


if __name__ == &quot;__main__&quot;:
    suite = unittest.TestSuite()
    suite.addTest(Testadd(&quot;test_add&quot;))
    runner = unittest.TextTestRunner()
    runner.run(suite)

</code></pre>
<p>pycharm执行结果：</p>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1592375744115.png" alt="" loading="lazy"></figure>
<p>命令行执行结果：</p>
<figure data-type="image" tabindex="3"><img src="https://liujinyang6.github.io/post-images/1592375752876.png" alt="" loading="lazy"></figure>
<p><strong>问题解决：</strong></p>
<ol>
<li>
<p>点击pycharm的右上角下拉菜单，点击Edit configurations</p>
</li>
<li>
<p>将Python tests里的对应文件的py.test for...或者unittest for...的文件删除（选中后点击左上角的减号）</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://liujinyang6.github.io/post-images/1592375874971.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>点击+，在下拉菜单中选择Python，然后在右边的script path里...选中所要运行的文件</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://liujinyang6.github.io/post-images/1592375885340.png" alt="" loading="lazy"></figure>
<ol>
<li>最后点击ok即可，再在所要运行的文件处（最好是main处）点击右键就会发现run unittest变成了run</li>
</ol>
<p>再次在pycharm中运行，well done</p>
<figure data-type="image" tabindex="6"><img src="https://liujinyang6.github.io/post-images/1592376021514.png" alt="" loading="lazy"></figure>
<p>总结：</p>
<p>执行unittest in demoSingle就会运行全部case</p>
<figure data-type="image" tabindex="7"><img src="https://liujinyang6.github.io/post-images/1592376034418.png" alt="" loading="lazy"></figure>
<p>而如果运行py文件本身就会只运行addsuite添加的用例</p>
<figure data-type="image" tabindex="8"><img src="https://liujinyang6.github.io/post-images/1592376044986.png" alt="" loading="lazy"></figure>
<hr>
<h4 id="三-单元测试框架实现模块整合-discover方法">三、单元测试框架实现模块整合---discover方法</h4>
<p>遍历所有测试脚本实现整合</p>
<p>使用测试套件单独管理全部功能的用例，利用测试套件整合</p>
<h5 id="testloader"><strong>TestLoader</strong></h5>
<p>该类根据各种标准负责加载测试用例，并返回给测试套件。正常情况下没有必要创建这个类的实例。unittest 提供了可以共享了 defaultTestLoader 类，可以使用其子类和方法创建实例，所以我们可以使用其下面的 discover()方法来创建一个实例。</p>
<p>既：</p>
<pre><code class="language-python">discover = unittest.defaultTestLoader.discover(start_dir，pattern='test*.py'，top_level_dir=None)



discover = unittest.TestLoader().discover(start_dir，pattern='test*.py'，top_level_dir=None)


#运行方法同上(上述方法2选1)
runner = unittest.TextTestRunner()

runner.run(discover)


</code></pre>
<p>找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。</p>
<p><code>start_dir</code> ：要测试的模块名或测试用例目录。（采用双斜线或目录前加r）</p>
<p><code>pattern='test*.py'</code>：表示用例文件名的匹配原则。星号“*”表示任意多个字符。</p>
<p><code>top_level_dir=None</code>：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是在该目录下则需要分别指定），默认为 None。</p>
<ul>
<li>注：<strong>discover</strong>发现的py文件不能控制先后顺序，只能通过文件名字的assccii码值来判断先后运行顺序，所以文件命名的时候可以通过testA……等来定义</li>
</ul>
<hr>
<h4 id="总结单元测试的执行方法一共有3种">总结：单元测试的执行方法一共有3种：</h4>
<p>第一种：通过<code>unittest.main()</code>加载全部test开头的用例并自动执行</p>
<p>第二种：通过添加测试套件的方法<code>addTest</code>，然后运行添加好的测试套件</p>
<p>第三种：通过<code>testloader</code>来加载指定目录下的test开头的用例，运行添加好的<code>discover</code></p>
<hr>
<h3 id="测试报告">测试报告</h3>
<p>1、通过打开/写入文件，编写测试报告</p>
<p>​	自己完成</p>
<p>2、通过 HTMLTestRunner.py 来生成测试报告。</p>
<p><code>HTMLTestRunner</code> 是 Python 标准库的 unittest 单元测试框架的一个扩展。它生成易于使用的 HTML 测试报告。 <code>HTMLTestRunner</code>是在 BSD 许可证下发布。</p>
<hr>
<h4 id="htmltestrunner">HTMLTestRunner</h4>
<p>首先要下 HTMLTestRunner.py 文件，下载地址：</p>
<p>http://tungwaiyip.info/software/HTMLTestRunner.html</p>
<p>HTMLTestRunner.py 本是一个.py 文件，将它放到 Python 安装目录下即可调用。</p>
<pre><code class="language-python"># 语法：
# 首先引入HTMLTestRunner包
import HTMLTestRunner

# 用法：
# 1----------定义个报告存放路径
filename = 'C:\\test_object\\report\\result.html'

# 2----------定义一个文件名，以写方式打开
fp = open(filename, 'wb')

# 3----------定义测试报告
runner =HTMLTestRunner.HTMLTestRunner(
		stream=fp,
		title=u'百度搜索测试报告',
		description=u'用例执行情况：')

# 4----------运行测试用例
runner.run(suite)

# 5----------关闭报告文件
fp.close()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python读写excel文件]]></title>
        <id>https://liujinyang6.github.io/post/python-du-xie-excel-wen-jian/</id>
        <link href="https://liujinyang6.github.io/post/python-du-xie-excel-wen-jian/">
        </link>
        <updated>2020-03-06T03:14:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="用xlrd和xlwt读写excel"><strong>用xlrd和xlwt读写excel</strong></h2>
<p>首先下载安装<strong>xlrd</strong>和<strong>xlwt</strong>这两个库</p>
<hr>
<h3 id="使用xlrd读取excel">使用xlrd读取excel</h3>
<pre><code class="language-python"># 导入包
import xlrd

# 1、打开excel
readbook = xlrd.open_workbook(r'\test\canying.xlsx')

# 2、获取读入的文件的sheet
sheet = readbook.sheet_by_index(1)#索引的方式，从0开始

sheet = readbook.sheet_by_name('sheet2')#通过名字定位sheet页

allsheetnames = readbook.sheet_names()#返回所有sheet页名字组成的列表

# 3、获取sheet的最大行数和列数
nrows = sheet.nrows#行

ncols = sheet.ncols#列

# 4、获取某个单元格的值
lng = sheet.cell(x,y)

lng = sheet.cell(0,0).value#获取1行1列的表格值，从0开始计数

lat = sheet.cell(1,4).value#获取2行5列的表格值，从0开始计数

# 5、获取某行/某列的值
row_value = sheet.row_values(x)  #获取x行的值，从0开始计数

col_value = sheet.col_values(y)  #获取y列的值，从0开始计数

</code></pre>
<hr>
<h3 id="使用xlutilscopy写excel"><strong>使用xlutils.copy写excel</strong></h3>
<pre><code class="language-python"># 导入前，先导入xlrd，需要依赖这个包
from xlutils.copy import copy

# 1-读取源excel中的所有数据（复制对象）
rb = xlrd.open_workbook(excel_dir + '\\' + 'data.xls')

# 2-复制读取的源excel对象
wb = copy(rb)

# 3-通过get_sheet()获取复制对象的sheet页
ws = wb.get_sheet(2)
    
# 4-对sheet页进行写入(传入x和y坐标，和具体写入的value)
ws.write(id,2,real)

ws.write(id,3,status)

# 5-保存excel（具体的excel路径+名称）
wb.save(self.excel_dir + '\\' + 'data.xls')

</code></pre>
<ul>
<li><strong>注意</strong>：运行代码时要关闭excel，否则会报错</li>
</ul>
<hr>
<h2 id="使用openpyxl库读写excel"><strong>使用openpyxl库读写excel</strong></h2>
<p>​	xlrd和xlwt处理的是xls文件，单个sheet最大行数是65535，如果数据量超过65535就会遇到：ValueError: row index was 65536, not allowed by .xls format。</p>
<p>​	如果有更大需要的，建议使用openpyxl函数，最大行数达到1048576。</p>
<pre><code class="language-python"># 导入包
import openpyxl

# 打开excel
file_path = r'D:\work\testdata.xlsx'

inwb = openpyxl.load_workbook(file_path) # 读取文件

# 获取打开的excel的sheet内容
sheetnames = inwb.get_sheet_names()  # 获取所有sheet页的name

ws = inwb.get_sheet_by_name(sheetnames[0])  # 按照name获取第一个sheet页的内容

# 获取sheet的最大行数和列数
rows = ws.max_row
cols = ws.max_column

# 获取某个单元格的值
ws.cell(1, 1).value

# 打开将写的表并添加sheet
outwb = openpyxl.Workbook()   # 打开一个将写的文件

outws = outwb.create_sheet(index=0) # 在将写的文件创建一个新的sheet

# 保存
saveExcel = r'D:\work\new.xlsx'

outwb.save(saveExcel) # 一定要记得保存
</code></pre>
<p><strong>注意</strong>：最后一定要记得保存，否则就前功尽弃喽😲</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python读取config.ini文件]]></title>
        <id>https://liujinyang6.github.io/post/python-du-qu-config-ini-wen-jian/</id>
        <link href="https://liujinyang6.github.io/post/python-du-qu-config-ini-wen-jian/">
        </link>
        <updated>2020-03-01T01:33:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="读取步骤">读取步骤：</h2>
<h2 id="1导入configparser">1.导入configparser</h2>
<pre><code class="language-python">import configparser
</code></pre>
<hr>
<h2 id="2实例化一个configparser对象读取目标配置文件内容">2.实例化一个configparser对象，读取目标配置文件内容</h2>
<pre><code class="language-python"># 1.实例化configparser对象
conf = configparser.ConfigParser()

# 2.获取目标.ini文件路径
file_path = os.path.dirname(‘xxxini文件路径’)+&quot;\\config.ini&quot;

# 3.读取目标文件内的内容(section)，当有中文的时候使用encoding
conf.read(file_path,encoding=&quot;utf-8-sig&quot;)

</code></pre>
<hr>
<ul>
<li>
<h3 id="configini文件格式">config.ini文件格式</h3>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592271873138.png" alt="" loading="lazy"></figure>
<hr>
<ul>
<li>
<h3 id="获取文件内的所有section">获取文件内的所有section</h3>
</li>
</ul>
<pre><code class="language-python">sections = conf.sections()
  
print('获取配置文件所有的section', sections)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的所有option">获取xx section下的所有option</h3>
</li>
</ul>
<pre><code class="language-python">options = conf.options('mysql')

print('获取指定section下所有option', options)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的所有键值对">获取xx section下的所有键值对</h3>
</li>
</ul>
<pre><code class="language-python">items = conf.items('mysql')

print('获取指定section下所有的键值对', items)
</code></pre>
<ul>
<li>
<h3 id="获取xx-section下的某个option">获取xx section下的某个option</h3>
</li>
</ul>
<pre><code class="language-python">value = conf.get('mysql', 'host')

print('获取指定的section下的option', value)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的邮箱服务器]]></title>
        <id>https://liujinyang6.github.io/post/chang-yong-de-you-xiang-fu-wu-qi/</id>
        <link href="https://liujinyang6.github.io/post/chang-yong-de-you-xiang-fu-wu-qi/">
        </link>
        <updated>2020-02-13T07:21:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-常用的邮箱服务器地址"><strong>一、常用的邮箱服务器地址</strong></h2>
<h3 id="阿里云邮箱mailaliyuncom">阿里云邮箱（mail.aliyun.com）:</h3>
<p>POP3服务器地址:pop3.aliyun.com（SSL加密端口：995；非加密端口：110）</p>
<p>SMTP服务器地址:smtp.aliyun.com（SSL加密端口：465；非加密端口：25）</p>
<p>IMAP服务器地址：imap.aliyun.com（SSL加密端口：993；非加密端口：143）</p>
<p></p>
<hr>
<h3 id="谷歌邮箱googlecom">谷歌邮箱(google.com)：</h3>
<p>POP3服务器地址:pop.gmail.com（SSL启用端口：995）</p>
<p>SMTP服务器地址:smtp.gmail.com（SSL启用端口：587）</p>
<p></p>
<hr>
<h3 id="新浪邮箱sinacom">新浪邮箱（sina.com）:</h3>
<p>POP3服务器地址:pop3.sina.com.cn（端口：110）</p>
<p>SMTP服务器地址:smtp.sina.com.cn（端口：25）</p>
<p></p>
<hr>
<h3 id="tom邮箱topcom">Tom邮箱（top.com）:</h3>
<p>POP3服务器地址:pop.tom.com（端口：110）</p>
<p>SMTP服务器地址:smtp.tom.com（端口：25）</p>
<p></p>
<hr>
<h3 id="网易邮箱163com">网易邮箱（163.com）:</h3>
<p>POP3服务器地址:pop.163.com（端口：110）</p>
<p>SMTP服务器地址:smtp.163.com（端口：25）</p>
<p></p>
<hr>
<h3 id="126邮箱">126邮箱:</h3>
<p>POP3服务器地址：pop.live.com（端口：995）</p>
<p>SMTP服务器地址:smtp.126.com（端口：25）</p>
<p></p>
<hr>
<h3 id="雅虎邮箱yahoocom">雅虎邮箱（yahoo.com）:</h3>
<p>POP3服务器地址:pop.mail.yahoo.com</p>
<p>SMTP服务器地址:smtp.mail.yahoo.com</p>
<p></p>
<hr>
<h3 id="雅虎中国yahoocomcn">雅虎中国（yahoo.com.cn）:</h3>
<p>POP3服务器地址:pop.mail.yahoo.com.cn（端口：995）</p>
<p>SMTP服务器地址:smtp.mail.yahoo.com.cn（端口：587）</p>
<p>雅虎邮箱POP3的SSL不启用端口为110，POP3的SSL启用端口995；SMTP的SSL不启用端口为25，SMTP的SSL启用端口为465。</p>
<p></p>
<hr>
<h3 id="foxmail邮箱foxmailcom">Foxmail邮箱（foxmail.com）：</h3>
<p>POP3服务器地址:POP.foxmail.com（端口：110）</p>
<p>SMTP服务器地址:SMTP.foxmail.com（端口：25）</p>
<p></p>
<hr>
<h3 id="qq邮箱mailqqcom">QQ邮箱（mail.qq.com）</h3>
<p>POP3服务器地址：pop.qq.com（端口：110）</p>
<p>SMTP服务器地址：smtp.qq.com（端口：25）</p>
<p>SMTP服务器需要身份验证。</p>
<p></p>
<hr>
<h3 id="搜狐邮箱sohucom">搜狐邮箱（sohu.com）:</h3>
<p>POP3服务器地址:pop3.sohu.com（端口：110）</p>
<p>SMTP服务器地址:smtp.sohu.com（端口：25）</p>
<p></p>
<hr>
<p></p>
<h3 id="hotmail邮箱hotmailcom">HotMail邮箱（hotmail.com）：</h3>
<p>POP3服务器地址：pop.live.com（端口：995）</p>
<p>SMTP服务器地址：smtp.live.com（端口：587</p>
<p></p>
<hr>
<h3 id="移动139邮箱">移动139邮箱:</h3>
<p>POP3服务器地址：POP.139.com（端口：110）</p>
<p>SMTP服务器地址：SMTP.139.com(端口：25)</p>
<p></p>
<hr>
<h3 id="中华网邮箱chinacom">中华网邮箱（china.com）:</h3>
<p>POP3服务器地址:pop.china.com（端口：110）</p>
<p>SMTP服务器地址:smtp.china.com（端口：25）</p>
<p></p>
<hr>
<p>以上便是常用邮箱SMTP服务器地址大全。可能还有些邮箱木有收集到。我们在设置代收发邮件软件时候，在POP3服务器地址及SMTP服务器地址处，只需要按照以上邮箱对应填写即可。</p>
<h2 id="二-如何打开pop3smtpimap功能">二、如何打开POP3/SMTP/IMAP功能？</h2>
<p>为了保障用户邮箱的安全，QQ邮箱设置了POP3/SMTP/IMAP的开关。系统缺省设置是“关闭”，在用户需要这些功能时请“开启”。</p>
<p>1.首先，登录邮箱，进入设置-帐户；</p>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1592551338857.jpg" alt="" loading="lazy"></figure>
<p>然后，在“帐户”设置中，找到设置项，进行设置，如下：</p>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1592551345658.jpg" alt="" loading="lazy"></figure>
<p>最后，保存设置，即打开了相应的服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Requests教程]]></title>
        <id>https://liujinyang6.github.io/post/requests-jiao-cheng/</id>
        <link href="https://liujinyang6.github.io/post/requests-jiao-cheng/">
        </link>
        <updated>2020-02-02T06:19:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="发送get请求">发送get请求</h3>
<h4 id="get请求">get请求</h4>
<ol>
<li>导入requests后，用get方法就能直接访问url地址，如：https://www.baidu.com</li>
<li>这里的r也就是response，请求后的返回值，可以调用response里的status_code方法查看状态码</li>
<li>状态码200只能说明这个接口访问的服务器地址是对的，并不能说明功能OK，一般要查看响应的内容，r.text（r.content()）是返回文本信息</li>
</ol>
<p>示例：</p>
<pre><code class="language-python"># 导入requests库
import requests

# 请求url
urlstr = 'https://www.baidu.com'

# 发送请求
r = requests.get(url = urlstr)

# 查看响应内容
print(r.text)


</code></pre>
<h4 id="携带参数发送get请求">携带参数发送get请求</h4>
<ol>
<li>再发一个带参数的get请求，如玩安卓搜索，地址为：https://www.wanandroid.com/article/query?k=Android</li>
<li>请求参数：k=Android，可以以字典的形式传参:{&quot;k&quot;: &quot; Android &quot;}</li>
<li>多个参数格式：{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot;}</li>
</ol>
<p>示例：</p>
<pre><code class="language-python"># 导入requests库
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/article/query'

# 请求参数
payload = {'k':'测试'}

# 发送请求
r = requests.get(url = urlstr, params = payload)

# 查看响应结果
print(r.text)
print(r.status_code)

</code></pre>
<h4 id="response">response</h4>
<p>response的返回内容还有其他更多信息：</p>
<ul>
<li>
<p><code>r.status_code</code>   #响应状态码</p>
</li>
<li>
<p><code>r.content</code>     #字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩</p>
</li>
<li>
<p><code>r.headers</code>     #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None</p>
</li>
<li>
<p><code>r.json()</code>     #Requests中内置的JSON解码器，处理后对应Python的dict</p>
</li>
<li>
<p><code>r.url</code>       # 获取url</p>
</li>
<li>
<p><code>r.encoding</code>    # 编码格式</p>
</li>
<li>
<p><code>r.cookies</code>     # 获取response返回的cookie</p>
</li>
<li>
<p><code>r.raw</code>       #返回原始响应体</p>
</li>
<li>
<p><code>r.text</code>      #字符串方式的响应体，会自动根据响应头部的字符编码进行解码</p>
</li>
<li>
<p><code>r.raise_for_status()</code>      #失败请求(非200响应)抛出异常</p>
</li>
</ul>
<hr>
<h3 id="发送post请求json">发送post请求（json）</h3>
<p>发送post的请求参考例子很简单，实际遇到的情况却是很复杂的，首先第一个post请求肯定是登录了，但登录是最难处理的。登录问题解决了，后面都简单了。</p>
<h4 id="post请求json形式">post请求(json形式)</h4>
<p>post的body是json类型，有两种方法来传递json数据：</p>
<ul>
<li>第一种：先导入json模块，用dumps方法转化成json格式。</li>
<li>第二种：使用json参数默认处理成json格式进行传递。</li>
<li>将返回结果，传到data里。</li>
</ul>
<p>示例1：</p>
<pre><code class="language-python"># 导入requests、json库
import requests
import json

# 发送post请求
urlstr = 'http://httpbin.org/post'

# 请求参数
payload = {'key1':'value1','key2':'value2'}

# 通过json.dumps方法将Python字符串转换成json类型
payload = json.dumps(payload)

# 发送请求
r = requests.post(url = urlstr, data = payload)

# 获取结果
print(r.text)

# 如果返回值为json格式可以通过r.json方法来查看结果
print(r.json())

</code></pre>
<p>示例2：</p>
<pre><code class="language-python"># 导入requests、json库
import requests
import json

# 发送post请求
urlstr = 'http://httpbin.org/post'

# 请求参数
payload = {'key1':'value1','key2':'value2'}

# 发送请求，接口请求为json数据，通过json=自动将Python数据类型转换为json数据类型
r = requests.post(url = urlstr, json = payload)

# 获取结果
print(r.text)

# 如果返回值为json格式可以通过r.json方法来查看结果
print(r.json())

</code></pre>
<h4 id="headers">headers</h4>
<p>以玩Android登录为例，抓包查看请求头，header为Python的字典类型，所以可以支持dict类型的所有操作方式添加header信息，可以直接定义{}，也可以通过dict[key]的方式添加。</p>
<p>示例：</p>
<pre><code class="language-python"># 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求头
header = {'User-Agent':'Molilla/6.0'}

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload, headers = header)

# 获取结果
print(r.text)
print(r.headers)

</code></pre>
<hr>
<h3 id="发送post请求data">发送post请求（data）</h3>
<p>前面示例的是传json参数，有些post请求不是传json类型数据的，下面就以传data参数为例。</p>
<h4 id="post请求表单形式">post请求(表单形式)</h4>
<p>用上面给的示例，做个简单修改，发个post请求，payload参数是字典类型，传到form里（注意post请求参数使用<code>data=</code>），示例中的response返回的是一个json，所以可以通过r.json的方式来查看结果，通过dict引用的方式取值dict[‘key’]</p>
<p>示例：</p>
<pre><code class="language-python"># 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload)

# 获取结果
print(r.text)

# 查看类型
print(type(r.json()))
# 查看后类型为字典类型，r.json()将response中返回的json处理成了dict

# 通过dict的key来访问对应的值
print(r.json()['data']['username'])

</code></pre>
<p>有时候body参数并不是json格式，是key=value格式，也就是前面介绍post请求四种数据类型里面的第二种。</p>
<h4 id="如何判断登录成功">如何判断登录成功？</h4>
<p>step 1 ：判断登录成功，可以抓取页面上的关键元素，比如：账号名称，注销按钮</p>
<p>step2  ：通过正则表达式提出这2个关键字</p>
<p>示例：</p>
<pre><code class="language-python"># 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload)

# 获取结果
print(r.text)

# 查看类型
print(type(r.json()))
# 查看后类型为字典类型，r.json()将response中返回的json处理成了dict

# 通过dict的key来访问对应的值
print(r.json()['data']['username'])

if r.json()['data']['username'] == payload['username']:
	
	print(&quot;登录成功！&quot;)
</code></pre>
<hr>
<h3 id="发https请求ssl">发https请求（ssl）</h3>
<p>本来最新的requests库V1.13.0是支持https请求的，但是一般写脚本时候，我们会用抓包工具fiddler，这时候会 报：requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)</p>
<p>解决方法：</p>
<ol>
<li>
<p>不启用fiddler，直接发https请求，不会有SSL问题（也就是说不想看到SSL问题，关掉fiddler就行）</p>
</li>
<li>
<p>启动fiddler抓包，错误提示就是上面这样的。首先我找了很多的资料，有很多人说关闭证书验证（verify=False））可以解决这个问题或者说是在进行GET时,指定SSL证书。</p>
<pre><code class="language-python">response = requests.get('http://www.baidu.com/', headers = header, verify=False)
</code></pre>
<p>但我用以上两种方法都没有完美解决此问题，而且有些还有后续错误比如InsecureRequestWarning</p>
<p>只要安装一下几个requests依赖包就可以解决此问题</p>
<pre><code class="language-python">pip install cryptography

pip install pyOpenSSL

pip install certifi
</code></pre>
</li>
</ol>
<hr>
<h3 id="session关联接口">session关联接口</h3>
<p>前面模拟登录了玩安卓，但这只是第一步，一般登录后，还会有其它的操作，如发帖，评论等，这时候如何保持会话呢？</p>
<h4 id="使用session登录">使用session登录</h4>
<ol>
<li>使用session登录 s = requests.session()</li>
<li>通过session函数自动携带上次请求返回的cookie信息，发送二次post请求</li>
</ol>
<p>示例：</p>
<pre><code class="language-python"># 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 初始化session对象
s = requests.session()

# 通过session对象发送post请求，服务器设置在本地的cookie会保存在本地
r = s.post(url = urlstr, data = payload)

# 通过session对象继续发送请求，自动携带上一个请求返回的cookie
r2 = s.get('https://www.wanandroid.com/lg/todo/list/0')

# 获取结果
print(r.text)
print(r2.text)
</code></pre>
<hr>
<h3 id="json数据处理">json数据处理</h3>
<p>有些post的请求参数是<code>json</code>格式的，这个前面post请求里面提到过，需要导入<code>json</code>模块处理。<br>
一般常见的接口返回数据也是<code>json</code>格式的，我们在做处理时候，往往只需要提取其中几个关键的参数就行，这时候就需要<code>json</code>来解析返回的数据了。</p>
<p>前提：<code>import json</code></p>
<p><code>json.dumps</code> 将 <strong>Python 对象</strong>编码成 <strong>JSON 字符串</strong>--------相当于------<code>encode编码</code></p>
<p><code>json.loads</code> 将<strong>已编码的 JSON 字符串</strong>解码为 <strong>Python 对象</strong>--------相当于------<code>decode解码</code></p>
<p><strong>Json</strong>简介：<strong>Json</strong>，全名 JavaScript Object Notation，是一种<strong>轻量级的数据交换格式</strong>,常用于http请求中。</p>
<h4 id="encodepython-json">Encode（python-&gt;json）</h4>
<p>首先说下为什么要encode，<code>python</code>里面bool值是<code>True</code>和<code>False</code>,<code>json</code>里面bool值是<code>true</code>和<code>false</code>,并且区分大小写，这就尴尬了，明明都是bool值。</p>
<p>在python里面写的代码，传到json里，肯定识别不了，所以需要把python的代码经过encode后成为json可识别的数据类型。</p>
<ol>
<li>举个简单例子，下图中dict类型经过<code>json.dumps()</code>后变成<code>str</code>，<code>True</code>变成了<code>true</code>,<code>False</code>变成了<code>fasle</code>.</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://liujinyang6.github.io/post-images/1594707616351.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>以下对应关系表是从json模块的源码里面爬出来的.python的数据类，经过encode成json的数据类型，对应的表如下：</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://liujinyang6.github.io/post-images/1594707625659.png" alt="" loading="lazy"></figure>
<h4 id="decodejson-python">Decode（json-&gt;python）</h4>
<ol>
<li>以登录成功返回结果：{&quot;success&quot;:true}为例，我们其实最想知道的是success这个字段返回的是True还是False</li>
<li>如果以content字节输出，返回的是一个字符串：{&quot;success&quot;:true}，这样获取后面那个结果就不方便了</li>
<li>如果经过json解码后，返回的就是一个字典：{u'success': True}，这样获取后面那个结果，就用字典的方式去取值：result2[&quot;success&quot;]</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://liujinyang6.github.io/post-images/1594707635239.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>同样json数据转化成python可识别的数据，对应的表关系如下</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://liujinyang6.github.io/post-images/1594707647259.png" alt="" loading="lazy"></figure>
<h4 id="案例分析">案例分析</h4>
<p>比如打开快递网：http://www.kuaidi.com/，搜索某个单号，判断它的状态是不是已签收</p>
<figure data-type="image" tabindex="5"><img src="https://liujinyang6.github.io/post-images/1594707666440.png" alt="" loading="lazy"></figure>
<p>实现代码如下：</p>
<figure data-type="image" tabindex="6"><img src="https://liujinyang6.github.io/post-images/1594707674773.png" alt="" loading="lazy"></figure>
<hr>
<h3 id="token登录">token登录</h3>
<p>有些登录不是用<code>cookie</code>来验证的，是用<code>token</code>参数来判断是否登录。<br>
token传参有两种一种是放在<strong>请求头</strong>里，本质上是跟cookie是一样的，只是换个单词而已；另外一种是在<strong>url请求参数</strong>里，这种更直观。</p>
<ol>
<li>如下图的这个登录，无cookies</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://liujinyang6.github.io/post-images/1594707685576.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>但是登录成功后有返回token</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://liujinyang6.github.io/post-images/1594707693875.png" alt="" loading="lazy"></figure>
<ol start="3">
<li>登录成功后继续操作其它页面，发现post请求的请求头，都会带token参数</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://liujinyang6.github.io/post-images/1594707704534.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>这种请求其实比cookie更简单，直接把登录后的token放到头部就行</li>
</ol>
<h4 id="token关联">token关联</h4>
<p>步骤：</p>
<ol>
<li>用脚本实现登录，获取token参数，获取后传参到请求头就可以了</li>
<li>如果登录有验证码，前面的脚本登录步骤就省略了，自己手动登录后获取token</li>
</ol>
<pre><code class="language-python">import requests

body = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}  # 这里账号密码是抓包后的数据

s = requests.session()

login_url = &quot;http://xxxx/login&quot;    # 自己找带token的网址

login_request = s.post(login_url, data = body)

# 这里token在返回的json里，可以直接提取
token = login_request.json()[&quot;token&quot;]

# 添加token到请求头部
header[&quot;token&quot;] = token

# 如果这个post请求头的其他参数变了，也可以直接更新
header[&quot;Content-Length&quot;] = &quot;9&quot;
body1 = {&quot;key&quot;: &quot;value&quot;}

# 调用登录后的其他接口
post_request = s.post(post_url, headers = header, data = body1)

# 查看结果
print(post_request.content)
</code></pre>
<hr>
<h3 id="携带cookie发送请求">携带cookie发送请求</h3>
<p>这里整理了4种携带cookie的方法：</p>
<h4 id="方法一">方法一：</h4>
<p>通过<code>r.cookies</code>手动获取上一请求返回的<code>cookie</code>来设置下次请求的<code>cookie</code></p>
<p>示例：</p>
<pre><code class="language-python">&quot;&quot;&quot;
通过r.cookies手动获取上一请求返回的cookie来设置下次请求的cookie
&quot;&quot;&quot;

# 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload)

# 获取结果
print(r.text)
# 获取返回的cookie
print(r.cookies)
# 获取返回的header
print(r.headers)

# 获取上次请求返回的response中的cookie，传递给下次请求
cookie = r.cookies

# 携带cookie发送请求
r2 = requests.get('http://www.wanandroid.com/lg/todo/list/0', cookies = cookie )

# 查看第二个请求的结果
print(r2.text)
print(r2.status_code)

</code></pre>
<h4 id="方法二">方法二：</h4>
<p>通过<code>rquests.session</code>自动设置<code>cookie</code>，来完成访问</p>
<pre><code class="language-python">&quot;&quot;&quot;
通过rquests.session自动设置cookie，来完成访问
&quot;&quot;&quot;

# 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 初始化session对象
s = requests.session()

# 通过session对象发送post请求，服务器设置在本地的cookie会保存在本地
r = s.post(url = urlstr, data = payload)

# 通过session对象继续发送请求，自动携带上一个请求返回的cookie
r2 = s.get('https://www.wanandroid.com/lg/todo/list/0')

# 获取结果
print(r.text)
print(r2.text)

</code></pre>
<h4 id="方法三">方法三：</h4>
<p>通过定制<code>cookie</code>，单独设置<code>cookie</code>来访问目标网址</p>
<pre><code class="language-python">&quot;&quot;&quot;
通过定制cookie，单独设置cookie来访问目标网址
&quot;&quot;&quot;

# 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload)
print(r.text)

print(r.cookies['JSESSIONID'])

# 获取上次请求返回的response中的cookie，通过字典的形式引用cookie返回的JSESSIONID，
# 放入下一次请求的cookie中
cookie = {
    'JSESSIONID':r.cookie['JSESSIONID']
}

# 携带cookie发送请求
r2 = requests.get('https://www.wanandroid.com/lg/todo/list/0',cookies = cookie)

# 查看结果
print(r2.text)
print(r2.headers)

</code></pre>
<h4 id="方法四">方法四：</h4>
<p>通过定制cookie，放入header来访问目标网址</p>
<pre><code class="language-python">&quot;&quot;&quot;
通过定制cookie，放入header来访问目标网址
&quot;&quot;&quot;

# 导入requests
import requests

# 请求url
urlstr = 'https://www.wanandroid.com/user/login'

# 请求参数
payload = {'username':'liu','password':'123456'}

# 发送post请求
r = requests.post(url = urlstr, data = payload)
print(r.text)
print(r.cookies)
print(r.headers)
print(r.cookies['JSESSIONID'])

# 获取上次请求返回的response中的cookie，通过字典的形式引用cookie返回的JSESSIONID，放入
# 下一次请求的header中
header = {
    'cookie':'JSESSIONID='+r.cookies['JSESSIONID']
}

# 携带header发送请求
r2 = requests.get('https://www.wanandroid.com/lg/todo/list/0',headers = header)

print(r2.text)
print(r2.headers)

# str.find方法返回-1表示没有找到，非-1表示找到
result = r2.text.find(&quot;已完成清单&quot;)
print(result)

if result != -1:
    
    print(&quot;查询成功！&quot;)
    
else:
    
    print(&quot;查询失败！&quot;)
    

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loadrunner脚本编写练习]]></title>
        <id>https://liujinyang6.github.io/post/loadrunner-jiao-ben-bian-xie-lian-xi/</id>
        <link href="https://liujinyang6.github.io/post/loadrunner-jiao-ben-bian-xie-lian-xi/">
        </link>
        <updated>2019-06-10T03:40:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="参数关联-检查点设置">参数关联、检查点设置</h3>
<pre><code class="language-c">Action()
{	
	int i;

	// 获取动态sessionid
	web_reg_save_param(&quot;sessionid&quot;,
		&quot;LB=&lt;input type=hidden name=userSession value=&quot;,
		&quot;RB=&gt;&quot;,
		&quot;Ord=1&quot;,
		&quot;Search=All&quot;,
		LAST);



	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:1080/WebTours/&quot;,LAST);

	// 设置登录检查点
    
	web_reg_find(&quot;Search=All&quot;,
		&quot;SaveCount=checkcount&quot;,
		&quot;Text=liang01&quot;,
		LAST);

	lr_start_transaction(&quot;login&quot;);

	web_submit_data(&quot;web_submit_data&quot;,
		&quot;Action=http://127.0.0.1:1080/WebTours/login.pl&quot;,
		&quot;Method=POST&quot;,
		&quot;TargetFrame=&quot;,
		&quot;Referer=&quot;,
		ITEMDATA,
		&quot;Name=userSession&quot;, &quot;Value={sessionid}&quot;, ENDITEM,
		&quot;Name=username&quot;, &quot;Value=liang01&quot;, ENDITEM,
		&quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM,
		LAST);
    
	// 将字符串转化为int
    
	i = atoi(lr_eval_string(&quot;{checkcount}&quot;));

	if (i&gt;0) {

		lr_end_transaction(&quot;login&quot;,LR_PASS);

	}
	else{
		lr_end_transaction(&quot;login&quot;,LR_FAIL);
	}



	return 0;
}

</code></pre>
<hr>
<h3 id="参数使用">参数使用</h3>
<pre><code class="language-c">Action()
{
	
	//将字符串&quot;test&quot;保存名为canshu的参数
	//将值存为参数
	lr_save_string(&quot;test&quot;,&quot;canshu&quot;);

 	lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;));

	lr_output_message(&quot;参数的值为:%s&quot;,lr_eval_string(&quot;{canshu}&quot;));
	
	//提取canshu参数的值
	//将值从参数中取出
	lr_eval_string(&quot;{canshu}&quot;);
}
</code></pre>
<hr>
<h3 id="高级关联">高级关联</h3>
<pre><code class="language-c">Action()
{

    // 关联获取大类
	web_reg_save_param(&quot;Did&quot;,
		&quot;LB=categoryId=&quot;,
		&quot;RB=\&quot;&gt;&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);


	// 访问首页
	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST);

	// 将一个字符串定义成一个参数
	// 随机获取数组某一元素的值
	lr_save_string(lr_paramarr_random(&quot;Did&quot;),&quot;did&quot;);
	
	
	// 根据索引获得数组某一元素的值 
    //lr_save_string(lr_paramarr_idx(&quot;Did&quot;,1),&quot;did&quot;);

	// 随机点击大类
	web_url(&quot;catlog&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={did}&quot;,LAST);

	return 0;
}

</code></pre>
<hr>
<h3 id="练习脚本">练习脚本：</h3>
<h4 id="按顺序点击访问页面">按顺序点击访问页面</h4>
<pre><code class="language-c">Action()
{
	int i;
	
	web_reg_save_param(&quot;fidarr&quot;,
		&quot;LB=forumdisplay&amp;fid=&quot;,
		&quot;RB=\&quot;&gt;&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);

	
	web_url(&quot;index&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);


	for (i=1;i&lt;=5;i++) {
		
		lr_save_string(lr_paramarr_idx(&quot;fidarr&quot;,i*(int)2),&quot;fid&quot;);

		web_url(&quot;catalog&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php?mod=forumdisplay&amp;fid={fid}&quot;,LAST);

	}


	return 0;
}

</code></pre>
<h4 id="随机登录账号">随机登录账号</h4>
<pre><code class="language-c">Action()
{
	int i = 0;

	web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);
    


	lr_start_transaction(&quot;login&quot;);

	web_submit_data(&quot;login&quot;,
		&quot;Action=http://127.0.0.1:8888/discuz/upload/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&quot;,
		&quot;Method=POST&quot;,
		&quot;TargetFrame=&quot;,
		&quot;Referer=&quot;,
		ITEMDATA,
		&quot;Name=fastloginfield&quot;, &quot;Value=username&quot;, ENDITEM,
		&quot;Name=username&quot;, &quot;Value={username}&quot;, ENDITEM,
		&quot;Name=password&quot;, &quot;Value=123&quot;, ENDITEM,
		&quot;Name=quickforward&quot;, &quot;Value=yes&quot;, ENDITEM,
		&quot;Name=handlekey&quot;, &quot;Value=ls&quot;, ENDITEM,
		LAST);

	

	web_reg_find(&quot;Search=All&quot;,
		&quot;SaveCount=namecount&quot;,
		&quot;Text={username}&quot;,
		LAST);


	web_url(&quot;discuz&quot;,&quot;URL=http://127.0.0.1:8888/discuz/upload/forum.php&quot;,LAST);


	i = atoi(lr_eval_string(&quot;{namecount}&quot;));

	
	if (i&gt;0) {
		lr_end_transaction(&quot;login&quot;,LR_PASS);
		lr_output_message(&quot;namecount的值为%d,出现次数大于0，事务通过&quot;,i);
	}
	else{
		lr_end_transaction(&quot;login&quot;,LR_FAIL);
		lr_output_message(&quot;namecount的值为%d，出现次数为0，事务失败&quot;,i);
	}
	


	return 0;
}

</code></pre>
<h4 id="随机点击任意一个大类再顺序点击其下的小类">随机点击任意一个大类，再顺序点击其下的小类</h4>
<pre><code class="language-c">Action()
{
	int i;

	web_reg_save_param(&quot;catalog_Big&quot;,
	&quot;LB=hidCategoryId\&quot; value=\&quot;&quot;,
	&quot;RB=\&quot; /&gt;&lt;/td&gt;&quot;,
	&quot;Ord=all&quot;,
	&quot;Search=All&quot;,
	LAST);



	web_url(&quot;petshop&quot;,&quot;URL=http://127.0.0.1/pet/&quot;,LAST);


	lr_save_string(lr_paramarr_random(&quot;catalog_Big&quot;),&quot;catalog&quot;);

	
	
	web_reg_save_param(&quot;catalog_Small&quot;,
		&quot;LB=&lt;a href='Items.aspx?productId=&quot;,
		&quot;RB=&amp;categoryId=&quot;,
		&quot;Ord=all&quot;,
		&quot;Search=All&quot;,
		LAST);


	web_url(&quot;random_catalog_big&quot;,&quot;URL=http://127.0.0.1/pet/Products.aspx?page=0&amp;categoryId={catalog}&quot;,LAST);


	  for (i=1;i&lt;=4;i++) {
		//获取小类的catalogId对应的值
		 lr_save_string(lr_paramarr_idx(&quot;catalog_Small&quot;,i*(int)2),&quot;catalog_small&quot;);

		
		web_submit_data(&quot;web_submit_data&quot;,
			&quot;Action=http://127.0.0.1/pet/Items.aspx&quot;,
			&quot;Method=GET&quot;,
			&quot;TargetFrame=&quot;,
			&quot;Referer=&quot;,
			ITEMDATA,
			&quot;Name=productId&quot;, &quot;Value={catalog_small}&quot;, ENDITEM,
			&quot;Name=categoryId&quot;, &quot;Value={catalog}&quot;, ENDITEM,
			LAST);


	  }


	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loadrunner脚本常用函数]]></title>
        <id>https://liujinyang6.github.io/post/loadrunner-jiao-ben-chang-yong-han-shu/</id>
        <link href="https://liujinyang6.github.io/post/loadrunner-jiao-ben-chang-yong-han-shu/">
        </link>
        <updated>2019-06-01T06:23:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="web_url">web_url()</h3>
<p>作用：模拟浏览器发出访问目标网址的请求=get 请求</p>
<p>语法：Web_url(“步骤名称”,“url=http：//xxxxx”,LAST);</p>
<p>eg:</p>
<p>web_url(“访问 baidu”，“url=http://www.baidu.com”，LAST);</p>
<hr>
<h3 id="web_submit_data">Web_submit_data()</h3>
<p>作用：向服务器提交表单数据,支持 post 和 get 方法</p>
<hr>
<h3 id="web_custom_request">web_custom_request()</h3>
<p>作用：自定义向服务器发送 http请求，支持的任意方法的请 求，可以代替<code>web_url</code> 和 <code>web_submit_data</code> 函数</p>
<hr>
<h3 id="web_reg_save_param">web_reg_save_param()</h3>
<p>作用：通过目标对象的左右边界获取服务器返回的动态数据</p>
<p>方法：工具栏→insert→new step 输入 <code>web_reg_save_param</code>，点击确定</p>
<p>步骤：</p>
<p>1、 确定需要关联的对象（动态的、变化的，服务器发送给客户端的）</p>
<p>2、 使用 httpwatch/fiddler 抓取目标对象，来确定该数据是由哪个请求产生的</p>
<p>3、 获取目标对象的左右边界，及请求的位置</p>
<p>4、 填写关联函数的参数名称，左右边界、查找数、查找位置</p>
<p>5、 用该参数名替换需要向服务器提交的动态数据，引用参数：{参数名}</p>
<ul>
<li>注意：从名称上知道关联函数是<code>注册型</code>函数，所以应该放在产生动态数据请求的前面，save_param 表示关联函数获取下来之后保存为一个参数，所以脚本中引用时应该加{} 。</li>
</ul>
<hr>
<h3 id="数组操作">数组操作</h3>
<pre><code class="language-c">//返回参数数组指定位置的参数的值  
lr_paramarr_idx(&quot;Did&quot;,1);  

//返回参数数组的元素（参数）的个数  
lr_paramarr_len(&quot;Did&quot;);  

//返回参数数组随机位置的参数的值  
lr_paramarr_random(&quot;Did&quot;); 
</code></pre>
<hr>
<h3 id="lr_think_time">lr_think_time（）</h3>
<p>作用：等待n秒</p>
<p>用法：lr_think_time（n）</p>
<hr>
<h3 id="事务函数">事务函数</h3>
<p>开始事务：lr_start_transaction(&quot;open&quot;);</p>
<p>结束事务：lr_end_transaction(&quot;open&quot;, LR_AUTO);</p>
<p>事务时间=响应时间+思考时间+浪费时间+函数自身执行时间，指的是客户端发出请 求到得到响应的整个过程所经历的时间。</p>
<p>事务的四种状态：<code>LR_AUTO</code>,<code>LR_STOP</code>,<code>LR_PASS</code>,<code>LR_FAIL</code></p>
<p>LR_AUTO: 系统自动判断依赖 http 返回的状态码,状态码为200事务就通过</p>
<hr>
<h3 id="检查点函数">检查点函数</h3>
<p>文本检查点函数，优先使用</p>
<p>Web_reg_find()</p>
<ul>
<li>注意：从名称上知道关联函数是<code>注册型</code>函数，所以应该放在检查数据请求的前面</li>
</ul>
<hr>
<h3 id="lr_eval_string">lr_eval_string()</h3>
<p>作用：取出参数的值</p>
<p>语法：lr_eval_string(“<code>{参数名}</code>”)</p>
<hr>
<h3 id="lr_save_string">lr_save_string()</h3>
<p>作用：保存字符串到一个参数</p>
<p>语法：lr_save_string(“<code>value</code>”，<code>参数名</code>);</p>
<hr>
<h3 id="lr_output_message">lr_output_message()</h3>
<p>作用：在控制台打印信息</p>
<hr>
<h3 id="类型转化">类型转化</h3>
<p><code>atoi()</code>：将字符串类型转为整型</p>
<p><code>itoa()</code>：将整型转为字符串类型</p>
<hr>
<h3 id="lr_rendezvous">lr_rendezvous()</h3>
<p>作用：设置集合点</p>
<p>用法：lr_rendezvous(&quot;集合点名称&quot;);</p>
]]></content>
    </entry>
</feed>